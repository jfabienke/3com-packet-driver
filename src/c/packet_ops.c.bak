/**
 * @file packet_ops.c
 * @brief Packet transmission and reception operations
 *
 * 3Com Packet Driver - Support for 3C515-TX and 3C509B NICs
 *
 * This file is part of the 3Com Packet Driver project.
 *
 */

#include <stdio.h>
#include <string.h>
#include "../include/packet_ops.h"
#include "../include/hardware.h"
#include "../include/routing.h"
#include "../include/static_routing.h"
#include "../include/arp.h"
#include "../include/buffer_alloc.h"
#include "../include/logging.h"
#include "../include/stats.h"
#include "../include/api.h"
#include "../include/flow_control.h"  // Phase 2.3: 802.3x Flow Control
#include "../include/production.h"

/* Additional error codes for hardware compatibility */
#ifndef ERROR_NO_DATA
#define ERROR_NO_DATA    -10    /* No data available */
#endif

/* Packet operation state */
static int packet_ops_initialized = 0;
static packet_stats_t packet_statistics = {0};

/* Production queue management state */
static struct {
    packet_queue_t tx_queues[4];    /* Priority-based TX queues */
    packet_queue_t rx_queue;        /* Single RX queue */
    uint32_t queue_full_events;     /* Queue overflow counter */
    uint32_t backpressure_events;   /* Flow control events */
    uint32_t priority_drops;        /* Priority-based drops */
    uint32_t adaptive_resizes;      /* Adaptive size changes */
    bool flow_control_active;       /* Flow control state */
    uint32_t last_queue_check;      /* Last queue health check */
} g_queue_state = {0};

/* Production queue management constants */
#define TX_QUEUE_URGENT_SIZE     32     /* Urgent priority queue size */
#define TX_QUEUE_HIGH_SIZE       64     /* High priority queue size */
#define TX_QUEUE_NORMAL_SIZE     128    /* Normal priority queue size */
#define TX_QUEUE_LOW_SIZE        64     /* Low priority queue size */
#define RX_QUEUE_SIZE           256     /* RX queue size */
#define QUEUE_WATERMARK_HIGH     80     /* High watermark percentage */
#define QUEUE_WATERMARK_LOW      20     /* Low watermark percentage */
#define FLOW_CONTROL_THRESHOLD   90     /* Flow control threshold percentage */
#define QUEUE_CHECK_INTERVAL_MS  100    /* Queue health check interval */

/* Internal helper functions */
static int route_packet_to_interface(const uint8_t *packet, uint16_t length, uint8_t dest_nic);

/* Production queue management functions */
static int packet_queue_init_all(void);
static void packet_queue_cleanup_all(void);
static int packet_enqueue_with_priority(packet_buffer_t *buffer, int priority);
static packet_buffer_t* packet_dequeue_by_priority(void);
static int packet_check_queue_health(void);
static void packet_apply_flow_control(void);
static void packet_adaptive_queue_resize(void);
static void packet_handle_queue_overflow(int priority);
static bool packet_should_drop_on_full(int priority, int queue_usage);
static uint32_t packet_calculate_queue_usage(packet_queue_t *queue);
static void packet_update_queue_stats(void);
static int packet_emergency_queue_drain(void);

/* Cold section: Initialization functions (discarded after init) */
#pragma code_seg("COLD_TEXT", "CODE")

/**
 * @brief Initialize packet operations subsystem
 * @param config Driver configuration
 * @return 0 on success, negative on error
 */
int packet_ops_init(const config_t *config) {
    int result;
    
    if (!config) {
        log_error("packet_ops_init: NULL config parameter");
        return PACKET_ERR_INVALID_PARAM;
    }
    
    log_info("Initializing packet operations subsystem with production queue management");
    
    /* Clear statistics */
    memset(&packet_statistics, 0, sizeof(packet_statistics));
    
    /* Initialize production queue management */
    result = packet_queue_init_all();
    if (result != 0) {
        log_error("Failed to initialize production queue management: %d", result);
        return result;
    }
    
    /* Initialize flow control and adaptive management */
    g_queue_state.flow_control_active = false;
    g_queue_state.last_queue_check = stats_get_timestamp();
    
    /* Initialize 802.3x Flow Control with CPU-efficient state management (Phase 2.3) */
    result = flow_control_init();
    if (result != 0) {
        log_warning("802.3x Flow Control initialization failed: %d, continuing without flow control", result);
        /* Continue - flow control is optional feature */
    } else {
        log_debug("802.3x Flow Control initialized with CPU-efficient state management");
    }
    
    packet_ops_initialized = 1;
    
    log_info("Packet operations subsystem initialized with production features");
    return 0;
}

/**
 * @brief Enhanced packet send with complete integration pipeline and CPU optimization
 * @param interface_num NIC interface number (0-based)
 * @param packet_data Packet data to send
 * @param length Packet length
 * @param dest_addr Destination MAC address (6 bytes)
 * @param handle Sender handle for tracking
 * @return 0 on success, negative on error
 */
int packet_send_enhanced(uint8_t interface_num, const uint8_t *packet_data, 
                        uint16_t length, const uint8_t *dest_addr, uint16_t handle) {
    nic_info_t *nic;
    buffer_desc_t *buffer;
    uint8_t *frame_buffer;
    int result;
    uint16_t frame_length;
    extern cpu_info_t g_cpu_info;
    
    if (!packet_data || length == 0 || !dest_addr) {
        log_error("packet_send_enhanced: Invalid parameters");
        return PACKET_ERR_INVALID_PARAM;
    }
    
    if (!packet_ops_initialized) {
        log_error("Packet operations not initialized");
        return PACKET_ERR_NOT_INITIALIZED;
    }
    
    log_debug("Sending packet: interface=%d, length=%d, handle=%04X", 
             interface_num, length, handle);
    
    /* Validate packet size */
    if (length < ETH_MIN_DATA || length > ETH_MAX_DATA) {
        log_error("Invalid packet data size: %d (must be %d-%d)", 
                 length, ETH_MIN_DATA, ETH_MAX_DATA);
        packet_statistics.tx_errors++;
        return PACKET_ERR_INVALID_SIZE;
    }
    
    /* Calculate total frame size including Ethernet header */
    frame_length = ETH_HEADER_LEN + length;
    if (frame_length < ETH_MIN_FRAME) {
        frame_length = ETH_MIN_FRAME; /* Will pad to minimum */
    }
    
    /* Get NIC by interface number */
    nic = hardware_get_nic(interface_num);
    if (!nic) {
        log_error("Invalid interface number: %d", interface_num);
        packet_statistics.tx_errors++;
        return PACKET_ERR_INVALID_NIC;
    }
    
    /* Check if NIC is active */
    if (!(nic->status & NIC_STATUS_ACTIVE)) {
        log_error("NIC %d is not active", interface_num);
        packet_statistics.tx_errors++;
        return PACKET_ERR_INVALID_NIC;
    }
    
    /* Allocate buffer using per-NIC buffer pools for resource isolation */
    buffer = buffer_alloc_nic_aware(nic->index, BUFFER_TYPE_TX, frame_length);
    if (!buffer) {
        log_error("Failed to allocate transmit buffer");
        packet_statistics.tx_errors++;
        return PACKET_ERR_NO_BUFFERS;
    }
    
    frame_buffer = (uint8_t*)buffer_get_data_ptr(buffer);
    if (!frame_buffer) {
        buffer_free_nic_aware(nic->index, buffer);
        return PACKET_ERR_NO_BUFFERS;
    }
    
    /* Build Ethernet frame with CPU-optimized copying */
    result = packet_build_ethernet_frame_optimized(frame_buffer, frame_length, 
                                                  dest_addr, nic->mac, 
                                                  0x0800, /* IP protocol */
                                                  packet_data, length);
    if (result < 0) {
        log_error("Failed to build Ethernet frame: %d", result);
        buffer_free_nic_aware(nic->index, buffer);
        packet_statistics.tx_errors++;
        return result;
    }
    
    /* Check 802.3x Flow Control before transmission (Phase 2.3) */
    if (flow_control_should_pause_transmission(nic->index)) {
        uint32_t pause_time = flow_control_get_pause_duration(nic->index);
        log_debug("Transmission paused due to 802.3x PAUSE frame, waiting %u ms", pause_time);
        
        /* Wait for pause duration with CPU-efficient wait */
        flow_control_wait_for_resume(nic->index, pause_time);
    }
    
    /* Send frame via hardware layer - Group 2A integration */
    result = hardware_send_packet(nic, frame_buffer, frame_length);
    if (result < 0) {
        log_error("Hardware send failed on interface %d: %d", interface_num, result);
        buffer_free_nic_aware(nic->index, buffer);
        packet_statistics.tx_errors++;
        return result;
    }
    
    /* Update statistics */
    packet_statistics.tx_packets++;
    packet_statistics.tx_bytes += frame_length;
    
    /* Free the buffer using per-NIC buffer pool */
    buffer_free_nic_aware(nic->index, buffer);
    
    log_debug("Packet sent successfully via interface %d (frame_size=%d)", interface_num, frame_length);
    return 0;
}

/* Restore default code segment before hot section */
#pragma code_seg()

/* Hot section: Performance-critical runtime functions */
#pragma code_seg("HOT_TEXT", "CODE")

/**
 * @brief Legacy packet send function for backward compatibility
 * @param packet Packet data
 * @param length Packet length
 * @param handle Sender handle
 * @return 0 on success, negative on error
 */
int packet_send(const uint8_t *packet, size_t length, uint16_t handle) {
    nic_info_t *nic;
    int result;
    
    if (!packet || length == 0) {
        log_error("packet_send: Invalid parameters");
        return PACKET_ERR_INVALID_PARAM;
    }
    
    if (!packet_ops_initialized) {
        log_error("Packet operations not initialized");
        return PACKET_ERR_NOT_INITIALIZED;
    }
    
    log_debug("Sending packet: length=%d, handle=%04X", length, handle);
    
    /* Validate packet size */
    if (length < PACKET_MIN_SIZE || length > PACKET_MAX_SIZE) {
        log_error("Invalid packet size: %d", length);
        packet_statistics.tx_errors++;
        return PACKET_ERR_INVALID_SIZE;
    }
    
    /* Use first available NIC for now - full routing can be implemented later */
    nic = hardware_get_nic(0);
    if (!nic) {
        log_error("No suitable NIC found for packet");
        packet_statistics.tx_errors++;
        return PACKET_ERR_INVALID_NIC;
    }
    
    /* Send packet via hardware layer */
    result = hardware_send_packet(nic, packet, length);
    if (result < 0) {
        log_error("Hardware send failed: %d", result);
        packet_statistics.tx_errors++;
        return result;
    }
    
    /* Update statistics */
    packet_statistics.tx_packets++;
    packet_statistics.tx_bytes += length;
    
    log_debug("Packet sent successfully via NIC %d", nic->type);
    return 0;
}

/**
 * @brief Receive a packet
 * @param buffer Buffer to store packet
 * @param max_length Maximum buffer size
 * @param actual_length Pointer to store actual packet length
 * @param nic_id NIC that received the packet
 * @return 0 on success, negative on error
 */
HOT_SECTION int packet_receive(uint8_t *buffer, size_t max_length, size_t *actual_length, int nic_id) {
    nic_info_t *nic;
    int result;
    
    if (!buffer || !actual_length || max_length == 0) {
        log_error("packet_receive: Invalid parameters");
        return PACKET_ERR_INVALID_PARAM;
    }
    
    if (!packet_ops_initialized) {
        log_error("Packet operations not initialized");
        return PACKET_ERR_NOT_INITIALIZED;
    }
    
    log_debug("Receiving packet from NIC %d, max_length=%d", nic_id, max_length);
    
    /* Get NIC information */
    nic = hardware_get_nic(nic_id);
    if (!nic) {
        log_error("Invalid NIC ID: %d", nic_id);
        return PACKET_ERR_INVALID_NIC;
    }
    
    /* Receive packet from hardware */
    result = hardware_receive_packet(nic, buffer, actual_length);
    if (result < 0) {
        if (result != PACKET_ERR_NO_PACKET) {
            log_error("Hardware receive failed: %d", result);
            packet_statistics.rx_errors++;
        }
        return result;
    }
    
    /* Validate received packet */
    if (*actual_length < PACKET_MIN_SIZE || *actual_length > max_length) {
        log_error("Invalid received packet size: %d", *actual_length);
        packet_statistics.rx_errors++;
        return PACKET_ERR_INVALID_SIZE;
    }
    
    /* Update statistics */
    packet_statistics.rx_packets++;
    packet_statistics.rx_bytes += *actual_length;
    
    log_debug("Packet received: length=%d", *actual_length);
    
    /* Process received packet through API layer */
    result = api_process_received_packet(buffer, *actual_length, nic_id);
    if (result < 0) {
        log_debug("No handlers for received packet");
        packet_statistics.rx_dropped++;
    }
    
    return 0;
}

/**
 * @brief Receive a packet from specific NIC with comprehensive processing
 * @param nic_index NIC interface number (0-based)
 * @param buffer Buffer to store received packet data  
 * @param length Pointer to buffer size (input) and actual packet length (output)
 * @return 0 on success, negative on error
 */
HOT_SECTION int packet_receive_from_nic(int nic_index, uint8_t *buffer, size_t *length) {
    nic_info_t *nic;
    buffer_desc_t *rx_buffer = NULL;
    eth_header_t eth_header;
    int result;
    size_t original_buffer_size;
    
    if (!buffer || !length || *length == 0) {
        log_error("packet_receive_from_nic: Invalid parameters");
        return PACKET_ERR_INVALID_PARAM;
    }
    
    if (!packet_ops_initialized) {
        log_error("Packet operations not initialized");
        return PACKET_ERR_NOT_INITIALIZED;
    }
    
    original_buffer_size = *length;
    log_debug("Receiving packet from NIC %d, max_length=%zu", nic_index, original_buffer_size);
    
    /* Get NIC by interface number */
    nic = hardware_get_nic(nic_index);
    if (!nic) {
        log_error("Invalid NIC interface: %d", nic_index);
        packet_statistics.rx_errors++;
        return PACKET_ERR_INVALID_NIC;
    }
    
    /* Check if NIC is active and ready to receive */
    if (!(nic->status & NIC_STATUS_ACTIVE)) {
        log_warning("NIC %d is not active for reception", nic_index);
        return PACKET_ERR_INVALID_NIC;
    }
    
    /* Allocate receive buffer using RX_COPYBREAK optimization */
    rx_buffer = rx_copybreak_alloc(ETH_MAX_FRAME);
    if (!rx_buffer) {
        log_error("Failed to allocate RX buffer for packet reception");
        packet_statistics.rx_errors++;
        return PACKET_ERR_NO_BUFFERS;
    }
    
    /* Receive packet from hardware via NIC operations vtable - Group 2A integration */
    size_t packet_length = rx_buffer->size;
    result = nic->ops->receive_packet(nic, (uint8_t*)buffer_get_data_ptr(rx_buffer), &packet_length);
    
    if (result < 0) {
        rx_copybreak_free(rx_buffer);
        if (result == ERROR_NO_DATA) {
            /* No packet available - not an error */
            *length = 0;
            return PACKET_ERR_NO_PACKET;
        } else {
            log_error("Hardware receive failed on NIC %d: %d", nic_index, result);
            packet_statistics.rx_errors++;
            return result;
        }
    }
    
    /* Validate minimum Ethernet frame size */
    if (packet_length < ETH_MIN_FRAME) {
        log_warning("Received runt frame: length=%zu", packet_length);
        rx_copybreak_free(rx_buffer);
        packet_statistics.rx_runt++;
        return PACKET_ERR_INVALID_SIZE;
    }
    
    if (packet_length > ETH_MAX_FRAME) {
        log_warning("Received oversized frame: length=%zu", packet_length);
        rx_copybreak_free(rx_buffer);
        packet_statistics.rx_oversize++;
        return PACKET_ERR_INVALID_SIZE;
    }
    
    /* Parse Ethernet header for validation and classification */
    uint8_t *packet_data = (uint8_t*)buffer_get_data_ptr(rx_buffer);
    result = packet_parse_ethernet_header(packet_data, packet_length, &eth_header);
    if (result < 0) {
        log_warning("Invalid Ethernet header in received packet");
        rx_copybreak_free(rx_buffer);
        packet_statistics.rx_errors++;
        return result;
    }
    
    /* Process 802.3x Flow Control PAUSE frames (Phase 2.3) */
    if (eth_header.ethertype == ETHERTYPE_FLOW_CONTROL) {
        log_debug("Processing 802.3x PAUSE frame");
        result = flow_control_process_received_packet(nic_index, packet_data, packet_length);
        if (result > 0) {
            log_debug("PAUSE frame processed, transmission throttled for %d ms", result);
            /* PAUSE frame consumed - don't pass to upper layers */
            rx_copybreak_free(rx_buffer);
            return PACKET_ERR_NO_PACKET; /* Not an error, just no packet for user */
        }
    }
    
    /* Update buffer status for flow control monitoring */
    uint32_t buffer_usage = calculate_buffer_usage_percentage(nic_index);
    flow_control_update_buffer_status(nic_index, buffer_usage);
    
    /* Validate destination address - check if packet is for us */
    if (!packet_is_for_us(packet_data, nic->mac) && 
        !packet_is_broadcast(packet_data) && 
        !packet_is_multicast(packet_data)) {
        /* Not for us - only process if in promiscuous mode */
        if (!(nic->status & NIC_STATUS_PROMISCUOUS)) {
            log_debug("Packet not addressed to us, dropping");
            rx_copybreak_free(rx_buffer);
            packet_statistics.rx_dropped++;
            return PACKET_ERR_NO_PACKET; /* Not an error, just not for us */
        }
    }
    
    /* Check if packet fits in provided buffer */
    if (packet_length > original_buffer_size) {
        log_error("Received packet too large for buffer: need %zu, have %zu", packet_length, original_buffer_size);
        rx_copybreak_free(rx_buffer);
        *length = packet_length; /* Return required size */
        return PACKET_ERR_INVALID_SIZE;
    }
    
    /* Copy packet to user buffer */
    memcpy(buffer, packet_data, packet_length);
    *length = packet_length;
    
    /* Update receive statistics */
    packet_statistics.rx_packets++;
    packet_statistics.rx_bytes += packet_length;
    
    /* Update detailed per-NIC statistics */
    packet_update_detailed_stats(nic_index, 1, packet_length, 0); /* 1 = RX, 0 = success */
    
    log_debug("Successfully received %zu byte packet from NIC %d (EtherType=0x%04X)", 
             packet_length, nic_index, ntohs(eth_header.ethertype));
    
    /* Process packet through enhanced processing pipeline if configured */
    result = packet_receive_process(packet_data, packet_length, nic_index);
    if (result < 0) {
        log_debug("Packet processing returned %d - packet delivered to user but not processed locally", result);
    }
    
    /* Free the receive buffer using RX_COPYBREAK */
    rx_copybreak_free(rx_buffer);
    
    return 0;
}

/**
 * @brief Enhanced received packet processing with complete integration
 * @param raw_data Raw packet data from NIC
 * @param length Raw packet length
 * @param nic_index Source NIC index
 * @return 0 on success, negative on error
 */
HOT_SECTION int packet_receive_process(uint8_t *raw_data, uint16_t length, uint8_t nic_index) {
    eth_header_t eth_header;
    uint8_t *payload_data;
    uint16_t payload_length;
    nic_info_t *nic;
    int result;
    
    if (!raw_data || length == 0) {
        return PACKET_ERR_INVALID_PARAM;
    }
    
    log_debug("Processing received packet: length=%d, nic=%d", length, nic_index);
    
    /* Validate minimum Ethernet frame size */
    if (length < ETH_MIN_FRAME) {
        log_warning("Received runt frame: length=%d", length);
        packet_statistics.rx_runt++;
        return PACKET_ERR_INVALID_SIZE;
    }
    
    if (length > ETH_MAX_FRAME) {
        log_warning("Received oversized frame: length=%d", length);
        packet_statistics.rx_oversize++;
        return PACKET_ERR_INVALID_SIZE;
    }
    
    /* Get NIC information */
    nic = hardware_get_nic(nic_index);
    if (!nic) {
        log_error("Invalid NIC index: %d", nic_index);
        return PACKET_ERR_INVALID_NIC;
    }
    
    /* Parse Ethernet header */
    result = packet_parse_ethernet_header(raw_data, length, &eth_header);
    if (result < 0) {
        log_warning("Invalid Ethernet header in received packet");
        packet_statistics.rx_errors++;
        return result;
    }
    
    /* Validate destination address - check if packet is for us */
    if (!packet_is_for_us(raw_data, nic->mac) && 
        !packet_is_broadcast(raw_data) && 
        !packet_is_multicast(raw_data)) {
        /* Not for us - only process if in promiscuous mode */
        if (!(nic->status & NIC_STATUS_PROMISCUOUS)) {
            log_debug("Packet not addressed to us, dropping");
            packet_statistics.rx_dropped++;
            return 0;
        }
    }
    
    /* Extract payload */
    payload_data = raw_data + ETH_HEADER_LEN;
    payload_length = length - ETH_HEADER_LEN;
    
    /* Validate payload size */
    if (payload_length < ETH_MIN_DATA) {
        /* Remove padding if present */
        if (payload_length > 0) {
            log_debug("Received padded frame, payload=%d", payload_length);
        }
    }
    
    /* Update receive statistics */
    packet_statistics.rx_packets++;
    packet_statistics.rx_bytes += length;
    
    /* Process specific protocol types */
    uint16_t ethertype = ntohs(eth_header.ethertype);
    
    switch (ethertype) {
        case ETH_P_ARP:
            /* Process ARP packets */
            if (arp_is_enabled()) {
                log_debug("Processing ARP packet");
                result = arp_process_received_packet(raw_data, length, nic_index);
                if (result < 0) {
                    log_warning("ARP processing failed: %d", result);
                    packet_statistics.rx_errors++;
                }
                return 0;
            }
            break;
            
        case ETH_P_IP:
            /* Process IP packets - may need routing */
            if (static_routing_is_enabled()) {
                uint8_t dest_nic;
                result = static_routing_process_ip_packet(payload_data, payload_length, 
                                                        nic_index, &dest_nic);
                if (result == SUCCESS && dest_nic != nic_index) {
                    /* Route packet to another interface */
                    log_debug("Routing IP packet from NIC %d to NIC %d", nic_index, dest_nic);
                    result = route_packet_to_interface(raw_data, length, dest_nic);
                    if (result == SUCCESS) {
                        packet_statistics.routed_packets++;
                    } else {
                        packet_statistics.rx_errors++;
                    }
                    return 0;
                }
            }
            break;
            
        default:
            /* Unknown protocol - fall through to API processing */
            break;
    }
    
    /* Check if packet should be routed to another interface (bridge mode) */
    result = routing_process_packet(raw_data, length, nic_index);
    if (result > 0) {
        /* Packet was routed */
        log_debug("Packet bridged to interface %d", result);
        packet_statistics.routed_packets++;
        return 0;
    }
    
    /* Deliver to local protocol stack via Group 2C API */
    result = api_process_received_packet(raw_data, length, nic_index);
    if (result < 0) {
        log_debug("No local handlers for ethertype 0x%04X", ethertype);
        packet_statistics.rx_dropped++;
    }
    
    return 0;
}

/**
 * @brief Legacy packet processing function for backward compatibility
 * @param packet Packet data
 * @param length Packet length
 * @param nic_id Source NIC ID
 * @return 0 on success, negative on error
 */
HOT_SECTION int packet_process_received(const uint8_t *packet, size_t length, int nic_id) {
    int result;
    
    if (!packet || length == 0) {
        return PACKET_ERR_INVALID_PARAM;
    }
    
    log_debug("Processing received packet: length=%d, nic=%d", length, nic_id);
    
    /* Basic packet validation */
    if (length < PACKET_MIN_SIZE) {
        log_warning("Received runt packet: length=%d", length);
        packet_statistics.rx_runt++;
        return PACKET_ERR_INVALID_SIZE;
    }
    
    if (length > PACKET_MAX_SIZE) {
        log_warning("Received oversized packet: length=%d", length);
        packet_statistics.rx_oversize++;
        return PACKET_ERR_INVALID_SIZE;
    }
    
    /* Check if packet should be routed to another interface */
    result = routing_process_packet(packet, length, nic_id);
    if (result > 0) {
        /* Packet was routed */
        log_debug("Packet routed to interface %d", result);
        packet_statistics.routed_packets++;
        return 0;
    }
    
    /* Deliver to local protocol stack */
    result = api_process_received_packet(packet, length, nic_id);
    if (result < 0) {
        log_debug("No local handlers for packet");
        packet_statistics.rx_dropped++;
    }
    
    return 0;
}

/**
 * @brief Enhanced packet transmission with retry logic and error handling
 * @param packet_data Packet data
 * @param length Packet length
 * @param dest_addr Destination MAC address
 * @param handle Sender handle
 * @param max_retries Maximum retry attempts
 * @return 0 on success, negative on error
 */
int packet_send_with_retry(const uint8_t *packet_data, uint16_t length,
                          const uint8_t *dest_addr, uint16_t handle,
                          int max_retries) {
    int result;
    int retry_count = 0;
    int backoff_delay = 1; /* Start with 1ms backoff */
    
    if (!packet_data || !dest_addr || length == 0) {
        return PACKET_ERR_INVALID_PARAM;
    }
    
    if (max_retries < 0 || max_retries > 10) {
        max_retries = 3; /* Default to 3 retries */
    }
    
    while (retry_count <= max_retries) {
        /* Try to get optimal NIC for transmission */
        int nic_index = packet_get_optimal_nic(packet_data, length);
        if (nic_index < 0) {
            /* Use multi-NIC load balancing */
            result = packet_send_multi_nic(packet_data, length, dest_addr, handle);
        } else {
            /* Use specifically selected NIC */
            result = packet_send_enhanced(nic_index, packet_data, length, dest_addr, handle);
        }
        
        /* Check for success */
        if (result == 0) {
            if (retry_count > 0) {
                log_info("Packet sent successfully after %d retries", retry_count);
            }
            return 0;
        }
        
        /* Handle specific error cases */
        switch (result) {
            case PACKET_ERR_NO_BUFFERS:
                /* Buffer exhaustion - wait for buffers to free up */
                log_warning("Buffer exhaustion, retrying after delay");
                packet_statistics.tx_errors++;
                break;
                
            case PACKET_ERR_INVALID_NIC:
                /* NIC failure - try failover */
                log_warning("NIC failure detected, attempting failover");
                if (nic_index >= 0) {
                    packet_handle_nic_failover(nic_index);
                }
                packet_statistics.tx_errors++;
                break;
                
            case PACKET_ERR_INVALID_SIZE:
                /* Invalid packet size - don't retry */
                log_error("Invalid packet size, aborting transmission");
                return result;
                
            default:
                log_warning("Transmission failed with error %d, retry %d/%d", 
                           result, retry_count, max_retries);
                packet_statistics.tx_errors++;
                break;
        }
        
        /* Check if we should retry */
        if (retry_count >= max_retries) {
            log_error("Maximum retries (%d) exceeded for packet transmission", max_retries);
            break;
        }
        
        /* Exponential backoff delay */
        /* In a real DOS environment, this would be a busy wait or timer-based delay */
        log_debug("Waiting %dms before retry %d", backoff_delay, retry_count + 1);
        
        /* Simple delay simulation - in real code this would use timer */
        for (volatile int i = 0; i < backoff_delay * 1000; i++) {
            /* Busy wait delay */
        }
        
        retry_count++;
        backoff_delay = (backoff_delay < 16) ? backoff_delay * 2 : 16; /* Cap at 16ms */
    }
    
    return result;
}

/**
 * @brief Enhanced packet receive with error recovery
 * @param buffer Buffer to store packet
 * @param max_length Maximum buffer size
 * @param actual_length Pointer to store actual packet length
 * @param nic_id NIC that received the packet
 * @param timeout_ms Timeout in milliseconds
 * @return 0 on success, negative on error
 */
int packet_receive_with_recovery(uint8_t *buffer, size_t max_length, 
                                size_t *actual_length, int nic_id, 
                                uint32_t timeout_ms) {
    uint32_t start_time;
    int result;
    nic_info_t *nic;
    
    if (!buffer || !actual_length || max_length == 0) {
        return PACKET_ERR_INVALID_PARAM;
    }
    
    if (!packet_ops_initialized) {
        return PACKET_ERR_NOT_INITIALIZED;
    }
    
    /* Get NIC information */
    nic = hardware_get_nic(nic_id);
    if (!nic) {
        log_error("Invalid NIC ID: %d", nic_id);
        return PACKET_ERR_INVALID_NIC;
    }
    
    /* Check if NIC is active */
    if (!(nic->status & NIC_STATUS_ACTIVE)) {
        log_warning("NIC %d is not active", nic_id);
        return PACKET_ERR_INVALID_NIC;
    }
    
    start_time = stats_get_timestamp(); /* Simplified timestamp */
    
    while (1) {
        /* Try to receive packet from hardware */
        result = hardware_receive_packet(nic, buffer, actual_length);
        
        /* Handle success */
        if (result == 0) {
            /* Validate received packet */
            if (*actual_length < PACKET_MIN_SIZE || *actual_length > max_length) {
                log_warning("Received invalid packet size: %d", *actual_length);
                packet_statistics.rx_errors++;
                continue; /* Try again */
            }
            
            /* Update statistics */
            packet_statistics.rx_packets++;
            packet_statistics.rx_bytes += *actual_length;
            
            log_debug("Packet received successfully: length=%d", *actual_length);
            return 0;
        }
        
        /* Handle specific errors */
        switch (result) {
            case PACKET_ERR_NO_PACKET:
                /* No packet available - this is normal */
                break;
                
            case PACKET_ERR_INVALID_SIZE:
                log_warning("Received packet with invalid size, discarding");
                packet_statistics.rx_errors++;
                continue;
                
            default:
                log_warning("Hardware receive error: %d", result);
                packet_statistics.rx_errors++;
                
                /* Check if NIC failed */
                if (!(nic->status & NIC_STATUS_ACTIVE)) {
                    log_error("NIC %d became inactive during receive", nic_id);
                    return PACKET_ERR_INVALID_NIC;
                }
                break;
        }
        
        /* Check timeout */
        if (timeout_ms > 0) {
            uint32_t elapsed = stats_get_timestamp() - start_time;
            if (elapsed >= timeout_ms) {
                log_debug("Receive timeout after %lu ms", elapsed);
                return PACKET_ERR_NO_PACKET;
            }
        }
        
        /* Small delay before retrying */
        for (volatile int i = 0; i < 100; i++) {
            /* Brief delay */
        }
    }
}

/**
 * @brief Queue a packet for transmission
 * @param packet Packet data
 * @param length Packet length
 * @param priority Transmission priority
 * @param handle Sender handle
 * @return 0 on success, negative on error
 */
HOT_SECTION int packet_queue_tx(const uint8_t *packet, size_t length, int priority, uint16_t handle) {
    packet_buffer_t *buffer;
    
    if (!packet || length == 0) {
        return PACKET_ERR_INVALID_PARAM;
    }
    
    /* Implement packet queuing with priority support */
    log_debug("Queuing packet for transmission: length=%d, priority=%d, handle=%04X",
             length, priority, handle);
    
    /* Queue packet based on priority */
    packet_queue_t *queue = &g_packet_queues[priority % MAX_PRIORITY_LEVELS];
    if (queue->count >= queue->max_size) {
        log_warning("Priority %d queue full, dropping packet", priority);
        return PACKET_ERR_QUEUE_FULL;
    }
    
    /* Allocate buffer for packet */
    buffer = buffer_alloc_packet_buffer(length);
    if (!buffer) {
        log_error("Failed to allocate packet buffer");
        packet_statistics.tx_buffer_full++;
        return PACKET_ERR_NO_BUFFERS;
    }
    
    /* Copy packet data */
    memcpy(buffer->data, packet, length);
    buffer->length = length;
    buffer->priority = priority;
    buffer->handle = handle;
    buffer->timestamp = stats_get_timestamp();
    
    /* For now, send immediately (no actual queuing) */
    /* In a full implementation, this would add to a priority queue */
    int result = packet_send(buffer->data, buffer->length, handle);
    
    /* Free the buffer */
    buffer_free_packet_buffer(buffer);
    
    return result;
}

/**
 * @brief Flush transmission queue
 * @return Number of packets sent, negative on error
 */
HOT_SECTION int packet_flush_tx_queue(void) {
    /* Implement queue flushing with priority ordering */
    log_debug("Flushing transmission queue");
    
    int packets_sent = 0;
    
    /* Process queues in priority order (high to low) */
    for (int priority = MAX_PRIORITY_LEVELS - 1; priority >= 0; priority--) {
        packet_queue_t *queue = &g_packet_queues[priority];
        
        while (queue->count > 0 && queue->head) {
            packet_buffer_t *buffer = queue->head;
            
            /* Attempt to send the packet */
            int result = packet_send_immediate(buffer->data, buffer->length, 0);
            if (result != SUCCESS) {
                /* Stop flushing if transmission fails */
                break;
            }
            
            /* Remove from queue - CRITICAL SECTION */
            __asm__ __volatile__("cli");  /* Disable interrupts */
            queue->head = buffer->next;
            if (!queue->head) {
                queue->tail = NULL;
            }
            queue->count--;
            __asm__ __volatile__("sti");  /* Enable interrupts */
            
            /* Free buffer */
            buffer_free_packet_buffer(buffer);
            packets_sent++;
        }
    }
    
    log_debug("Flushed %d packets from transmission queues", packets_sent);
    return packets_sent;
}

/**
 * @brief Get packet statistics
 * @param stats Pointer to store statistics
 * @return 0 on success, negative on error
 */
int packet_get_statistics(packet_stats_t *stats) {
    if (!stats) {
        return PACKET_ERR_INVALID_PARAM;
    }
    
    *stats = packet_statistics;
    return 0;
}

/**
 * @brief Enhanced packet statistics collection and monitoring
 * @param nic_index NIC index for per-NIC statistics
 * @param packet_type Type of packet (TX/RX)
 * @param length Packet length
 * @param result Operation result (0 = success, negative = error)
 */
void packet_update_detailed_stats(int nic_index, int packet_type, uint16_t length, int result) {
    nic_info_t *nic;
    
    /* Update global statistics */
    if (packet_type == 0) { /* TX */
        if (result == 0) {
            packet_statistics.tx_packets++;
            packet_statistics.tx_bytes += length;
        } else {
            packet_statistics.tx_errors++;
        }
    } else { /* RX */
        if (result == 0) {
            packet_statistics.rx_packets++;
            packet_statistics.rx_bytes += length;
        } else {
            packet_statistics.rx_errors++;
        }
    }
    
    /* Update per-NIC statistics if valid NIC index */
    nic = hardware_get_nic(nic_index);
    if (nic) {
        if (packet_type == 0) { /* TX */
            if (result == 0) {
                nic->tx_packets++;
                nic->tx_bytes += length;
            } else {
                nic->tx_errors++;
            }
        } else { /* RX */
            if (result == 0) {
                nic->rx_packets++;
                nic->rx_bytes += length;
            } else {
                nic->rx_errors++;
            }
        }
    }
}

/**
 * @brief Get comprehensive packet driver performance metrics
 * @param metrics Pointer to store performance metrics
 * @return 0 on success, negative on error
 */
int packet_get_performance_metrics(packet_performance_metrics_t *metrics) {
    int total_nics;
    nic_info_t *nic;
    uint32_t total_tx_packets = 0;
    uint32_t total_rx_packets = 0;
    uint32_t total_errors = 0;
    
    if (!metrics) {
        return PACKET_ERR_INVALID_PARAM;
    }
    
    memset(metrics, 0, sizeof(packet_performance_metrics_t));
    
    /* Copy basic statistics */
    metrics->tx_packets = packet_statistics.tx_packets;
    metrics->rx_packets = packet_statistics.rx_packets;
    metrics->tx_bytes = packet_statistics.tx_bytes;
    metrics->rx_bytes = packet_statistics.rx_bytes;
    metrics->tx_errors = packet_statistics.tx_errors;
    metrics->rx_errors = packet_statistics.rx_errors;
    metrics->rx_dropped = packet_statistics.rx_dropped;
    
    /* Calculate performance ratios */
    total_tx_packets = packet_statistics.tx_packets;
    total_rx_packets = packet_statistics.rx_packets;
    total_errors = packet_statistics.tx_errors + packet_statistics.rx_errors;
    
    if (total_tx_packets > 0) {
        metrics->tx_error_rate = (packet_statistics.tx_errors * 100) / total_tx_packets;
    }
    
    if (total_rx_packets > 0) {
        metrics->rx_error_rate = (packet_statistics.rx_errors * 100) / total_rx_packets;
        metrics->rx_drop_rate = (packet_statistics.rx_dropped * 100) / total_rx_packets;
    }
    
    /* Calculate throughput (simplified - packets per second estimate) */
    /* In real implementation, this would use actual time measurements */
    metrics->tx_throughput = total_tx_packets; /* Simplified */
    metrics->rx_throughput = total_rx_packets; /* Simplified */
    
    /* Aggregate per-NIC statistics */
    total_nics = hardware_get_nic_count();
    for (int i = 0; i < total_nics && i < MAX_NICS; i++) {
        nic = hardware_get_nic(i);
        if (nic) {
            metrics->nic_stats[i].active = (nic->status & NIC_STATUS_ACTIVE) ? 1 : 0;
            metrics->nic_stats[i].link_up = (nic->status & NIC_STATUS_LINK_UP) ? 1 : 0;
            metrics->nic_stats[i].speed = (nic->status & NIC_STATUS_100MBPS) ? 100 : 10;
            metrics->nic_stats[i].full_duplex = (nic->status & NIC_STATUS_FULL_DUPLEX) ? 1 : 0;
            metrics->nic_stats[i].tx_packets = nic->tx_packets;
            metrics->nic_stats[i].rx_packets = nic->rx_packets;
            metrics->nic_stats[i].tx_errors = nic->tx_errors;
            metrics->nic_stats[i].rx_errors = nic->rx_errors;
        }
    }
    
    metrics->active_nics = total_nics;
    metrics->collection_time = stats_get_timestamp();
    
    return 0;
}

/**
 * @brief Monitor packet driver health and performance
 * @return Health status (0 = healthy, positive = warnings, negative = errors)
 */
int packet_monitor_health(void) {
    int health_score = 0;
    int total_nics;
    nic_info_t *nic;
    uint32_t total_packets;
    uint32_t total_errors;
    
    /* Check if packet operations are initialized */
    if (!packet_ops_initialized) {
        log_warning("Packet operations not initialized");
        return -10;
    }
    
    /* Check for active NICs */
    total_nics = hardware_get_nic_count();
    if (total_nics == 0) {
        log_error("No NICs available");
        return -20;
    }
    
    int active_nics = 0;
    for (int i = 0; i < total_nics; i++) {
        nic = hardware_get_nic(i);
        if (nic && (nic->status & NIC_STATUS_ACTIVE)) {
            active_nics++;
            
            /* Check link status */
            if (!(nic->status & NIC_STATUS_LINK_UP)) {
                log_warning("NIC %d link is down", i);
                health_score += 5;
            }
            
            /* Check error rates */
            if (nic->tx_packets > 0) {
                uint32_t tx_error_rate = (nic->tx_errors * 100) / nic->tx_packets;
                if (tx_error_rate > 10) {
                    log_warning("NIC %d high TX error rate: %lu%%", i, tx_error_rate);
                    health_score += 10;
                } else if (tx_error_rate > 5) {
                    health_score += 5;
                }
            }
            
            if (nic->rx_packets > 0) {
                uint32_t rx_error_rate = (nic->rx_errors * 100) / nic->rx_packets;
                if (rx_error_rate > 10) {
                    log_warning("NIC %d high RX error rate: %lu%%", i, rx_error_rate);
                    health_score += 10;
                } else if (rx_error_rate > 5) {
                    health_score += 5;
                }
            }
        }
    }
    
    if (active_nics == 0) {
        log_error("No active NICs available");
        return -30;
    }
    
    /* Check global error rates */
    total_packets = packet_statistics.tx_packets + packet_statistics.rx_packets;
    total_errors = packet_statistics.tx_errors + packet_statistics.rx_errors;
    
    if (total_packets > 0) {
        uint32_t global_error_rate = (total_errors * 100) / total_packets;
        if (global_error_rate > 15) {
            log_warning("High global error rate: %lu%%", global_error_rate);
            health_score += 15;
        } else if (global_error_rate > 10) {
            health_score += 10;
        } else if (global_error_rate > 5) {
            health_score += 5;
        }
    }
    
    /* Check buffer utilization */
    if (packet_statistics.tx_buffer_full > 0) {
        log_warning("TX buffer exhaustion events: %lu", packet_statistics.tx_buffer_full);
        health_score += 5;
    }
    
    /* Log health status */
    if (health_score == 0) {
        log_debug("Packet driver health: EXCELLENT");
    } else if (health_score < 10) {
        log_info("Packet driver health: GOOD (score: %d)", health_score);
    } else if (health_score < 25) {
        log_warning("Packet driver health: FAIR (score: %d)", health_score);
    } else {
        log_warning("Packet driver health: POOR (score: %d)", health_score);
    }
    
    return health_score;
}

/**
 * @brief Print detailed packet driver statistics
 */
void packet_print_detailed_stats(void) {
    int total_nics;
    nic_info_t *nic;
    
    log_info("=== Packet Driver Statistics ===");
    log_info("Global Counters:");
    log_info("  TX: %lu packets, %lu bytes, %lu errors",
             packet_statistics.tx_packets,
             packet_statistics.tx_bytes,
             packet_statistics.tx_errors);
    log_info("  RX: %lu packets, %lu bytes, %lu errors, %lu dropped",
             packet_statistics.rx_packets,
             packet_statistics.rx_bytes,
             packet_statistics.rx_errors,
             packet_statistics.rx_dropped);
    log_info("  Routed: %lu packets", packet_statistics.routed_packets);
    log_info("  Buffer events: %lu TX full", packet_statistics.tx_buffer_full);
    
    /* Per-NIC statistics */
    total_nics = hardware_get_nic_count();
    for (int i = 0; i < total_nics; i++) {
        nic = hardware_get_nic(i);
        if (nic) {
            log_info("NIC %d (%s):", i, 
                    (nic->status & NIC_STATUS_ACTIVE) ? "ACTIVE" : "INACTIVE");
            log_info("  Status: Link=%s, Speed=%dMbps, Duplex=%s",
                    (nic->status & NIC_STATUS_LINK_UP) ? "UP" : "DOWN",
                    (nic->status & NIC_STATUS_100MBPS) ? 100 : 10,
                    (nic->status & NIC_STATUS_FULL_DUPLEX) ? "FULL" : "HALF");
            log_info("  TX: %lu packets, %lu bytes, %lu errors",
                    nic->tx_packets, nic->tx_bytes, nic->tx_errors);
            log_info("  RX: %lu packets, %lu bytes, %lu errors",
                    nic->rx_packets, nic->rx_bytes, nic->rx_errors);
        }
    }
    
    log_info("=== End Statistics ===");
}

/**
 * @brief Reset packet statistics
 * @return 0 on success
 */
int packet_reset_statistics(void) {
    int total_nics;
    nic_info_t *nic;
    
    log_info("Resetting packet statistics");
    memset(&packet_statistics, 0, sizeof(packet_statistics));
    
    /* Reset per-NIC statistics as well */
    total_nics = hardware_get_nic_count();
    for (int i = 0; i < total_nics; i++) {
        nic = hardware_get_nic(i);
        if (nic) {
            nic->tx_packets = 0;
            nic->rx_packets = 0;
            nic->tx_bytes = 0;
            nic->rx_bytes = 0;
            nic->tx_errors = 0;
            nic->rx_errors = 0;
            nic->tx_dropped = 0;
            nic->rx_dropped = 0;
        }
    }
    
    return 0;
}"

/**
 * @brief Check if packet operations are initialized
 * @return 1 if initialized, 0 otherwise
 */
int packet_ops_is_initialized(void) {
    return packet_ops_initialized;
}

/**
 * @brief Direct PIO packet send optimization for 3c509B (Sprint 1.2)
 * Eliminates intermediate buffer allocation and memcpy operations
 * @param interface_num NIC interface number
 * @param dest_addr Destination MAC address
 * @param ethertype Ethernet type/protocol
 * @param payload Payload data (from stack)
 * @param payload_len Payload length
 * @return 0 on success, negative on error
 */
int packet_send_direct_pio_3c509b(uint8_t interface_num, const uint8_t *dest_addr,
                                 uint16_t ethertype, const void* payload, uint16_t payload_len) {
    nic_info_t *nic;
    int result;
    
    /* Validate parameters */
    if (!dest_addr || !payload || payload_len == 0 || payload_len > ETH_MAX_DATA) {
        log_error("Invalid parameters for direct PIO send");
        packet_statistics.tx_errors++;
        return PACKET_ERR_INVALID_PARAM;
    }
    
    /* Get NIC information */
    nic = hardware_get_nic(interface_num);
    if (!nic) {
        log_error("Invalid interface number: %d", interface_num);
        packet_statistics.tx_errors++;
        return PACKET_ERR_INVALID_NIC;
    }
    
    /* Check if NIC is active */
    if (!(nic->status & NIC_STATUS_ACTIVE)) {
        log_error("NIC %d is not active", interface_num);
        packet_statistics.tx_errors++;
        return PACKET_ERR_INVALID_NIC;
    }
    
    /* Check if this is a 3c509B NIC */
    if (nic->type != NIC_TYPE_3C509B) {
        log_debug("Direct PIO optimization only available for 3c509B, NIC %d is type %d", 
                 interface_num, nic->type);
        packet_statistics.tx_errors++;
        return PACKET_ERR_NOT_SUPPORTED;
    }
    
    /* Use 3c509B direct PIO transmission with header construction */
    result = send_packet_direct_pio_with_header(nic, dest_addr, ethertype, payload, payload_len);
    if (result != SUCCESS) {
        log_error("Direct PIO transmission failed on interface %d: %d", interface_num, result);
        packet_statistics.tx_errors++;
        return result;
    }
    
    /* Update global statistics */
    packet_statistics.tx_packets++;
    packet_statistics.tx_bytes += ETH_HEADER_LEN + payload_len;
    
    log_debug("Successfully sent packet via direct PIO on interface %d: %d bytes", 
             interface_num, ETH_HEADER_LEN + payload_len);
    
    return SUCCESS;
}

/**
 * @brief Cleanup packet operations
 * @return 0 on success, negative on error
 */
/**
 * @brief Build an Ethernet frame with header and payload
 * @param frame_buffer Buffer to build frame in
 * @param frame_size Size of frame buffer
 * @param dest_mac Destination MAC address
 * @param src_mac Source MAC address  
 * @param ethertype Ethernet type/protocol
 * @param payload Payload data
 * @param payload_len Payload length
 * @return 0 on success, negative on error
 */
int packet_build_ethernet_frame(uint8_t *frame_buffer, uint16_t frame_size,
                               const uint8_t *dest_mac, const uint8_t *src_mac,
                               uint16_t ethertype, const uint8_t *payload,
                               uint16_t payload_len) {
    uint16_t frame_len;
    
    if (!frame_buffer || !dest_mac || !src_mac || !payload) {
        return PACKET_ERR_INVALID_PARAM;
    }
    
    /* Calculate required frame length */
    frame_len = ETH_HEADER_LEN + payload_len;
    if (frame_len > frame_size) {
        return PACKET_ERR_INVALID_SIZE;
    }
    
    /* Build Ethernet header */
    memcpy(frame_buffer, dest_mac, ETH_ALEN);                    /* Destination MAC */
    memcpy(frame_buffer + ETH_ALEN, src_mac, ETH_ALEN);          /* Source MAC */
    *(uint16_t*)(frame_buffer + 2 * ETH_ALEN) = htons(ethertype); /* EtherType */
    
    /* Copy payload */
    memcpy(frame_buffer + ETH_HEADER_LEN, payload, payload_len);
    
    /* Pad to minimum frame size if necessary */
    if (frame_len < ETH_MIN_FRAME) {
        memset(frame_buffer + frame_len, 0, ETH_MIN_FRAME - frame_len);
        frame_len = ETH_MIN_FRAME;
    }
    
    log_debug("Built Ethernet frame: len=%d, type=0x%04X", frame_len, ethertype);
    return frame_len;
}

/**
 * @brief Build Ethernet frame with CPU-optimized copying for better performance
 * @param frame_buffer Buffer to build frame in
 * @param frame_size Size of frame buffer
 * @param dest_mac Destination MAC address
 * @param src_mac Source MAC address  
 * @param ethertype Ethernet type/protocol
 * @param payload Payload data
 * @param payload_len Payload length
 * @return Frame length on success, negative on error
 */
int packet_build_ethernet_frame_optimized(uint8_t *frame_buffer, uint16_t frame_size,
                                         const uint8_t *dest_mac, const uint8_t *src_mac,
                                         uint16_t ethertype, const uint8_t *payload,
                                         uint16_t payload_len) {
    uint16_t frame_len;
    extern cpu_info_t g_cpu_info;
    
    if (!frame_buffer || !dest_mac || !src_mac || !payload) {
        return PACKET_ERR_INVALID_PARAM;
    }
    
    /* Calculate required frame length */
    frame_len = ETH_HEADER_LEN + payload_len;
    if (frame_len > frame_size) {
        return PACKET_ERR_INVALID_SIZE;
    }
    
    /* Build Ethernet header using CPU-optimized copying */
    memory_copy_optimized(frame_buffer, dest_mac, ETH_ALEN);                    /* Destination MAC */
    memory_copy_optimized(frame_buffer + ETH_ALEN, src_mac, ETH_ALEN);          /* Source MAC */
    *(uint16_t*)(frame_buffer + 2 * ETH_ALEN) = htons(ethertype);               /* EtherType */
    
    /* Use fast-path copying based on payload size */
    if (payload_len <= 64 && g_cpu_info.type >= CPU_TYPE_80286) {
        /* Small payload - use specialized fast copy */
        packet_copy_small_payload(frame_buffer + ETH_HEADER_LEN, payload, payload_len);
    } else if (payload_len <= 512 && g_cpu_info.type >= CPU_TYPE_80386) {
        /* Medium payload - use 32-bit optimized copy */
        memory_copy_optimized(frame_buffer + ETH_HEADER_LEN, payload, payload_len);
    } else {
        /* Large payload or older CPU - use standard copy */
        memory_copy_optimized(frame_buffer + ETH_HEADER_LEN, payload, payload_len);
    }
    
    /* Pad to minimum frame size if necessary using optimized memset */
    if (frame_len < ETH_MIN_FRAME) {
        uint16_t pad_len = ETH_MIN_FRAME - frame_len;
        memory_set_optimized(frame_buffer + frame_len, 0, pad_len);
        frame_len = ETH_MIN_FRAME;
    }
    
    log_debug("Built optimized Ethernet frame: len=%d, type=0x%04X, CPU=%s", 
             frame_len, ethertype, cpu_type_to_string(g_cpu_info.type));
    return frame_len;
}

/**
 * @brief Fast copy for small payloads (64 bytes) using assembly fast paths
 * @param dest Destination buffer
 * @param src Source buffer  
 * @param len Length to copy
 */
HOT_SECTION static void packet_copy_small_payload(uint8_t *dest, const uint8_t *src, uint16_t len) {
    extern cpu_info_t g_cpu_info;
    
    if (len <= 64 && g_cpu_info.type >= CPU_TYPE_80386) {
        /* Use assembly fast path for 64-byte copy if available */
        /* This would call the packet_copy_64_bytes function from assembly */
        if (len == 64) {
            /* Call assembly 64-byte optimized copy */
            /* packet_copy_64_bytes(src, dest); - Assembly call would go here */
            memory_copy_optimized(dest, src, len);
        } else {
            /* Use regular optimized copy for non-standard sizes */
            memory_copy_optimized(dest, src, len);
        }
    } else {
        /* Fallback to regular copy */
        memory_copy_optimized(dest, src, len);
    }
}

/**
 * @brief Parse Ethernet header from received frame
 * @param frame_data Frame data
 * @param frame_len Frame length
 * @param header Pointer to store parsed header
 * @return 0 on success, negative on error
 */
int packet_parse_ethernet_header(const uint8_t *frame_data, uint16_t frame_len,
                                eth_header_t *header) {
    if (!frame_data || !header || frame_len < ETH_HEADER_LEN) {
        return PACKET_ERR_INVALID_PARAM;
    }
    
    /* Extract header fields */
    memcpy(header->dest_mac, frame_data, ETH_ALEN);
    memcpy(header->src_mac, frame_data + ETH_ALEN, ETH_ALEN);
    header->ethertype = ntohs(*(uint16_t*)(frame_data + 2 * ETH_ALEN));
    
    log_debug("Parsed Ethernet header: type=0x%04X", header->ethertype);
    return 0;
}

/**
 * @brief Check if packet is addressed to our MAC
 * @param frame_data Frame data
 * @param our_mac Our MAC address
 * @return true if packet is for us
 */
bool packet_is_for_us(const uint8_t *frame_data, const uint8_t *our_mac) {
    if (!frame_data || !our_mac) {
        return false;
    }
    
    return memcmp(frame_data, our_mac, ETH_ALEN) == 0;
}

/**
 * @brief Check if packet is broadcast
 * @param frame_data Frame data
 * @return true if broadcast packet
 */
bool packet_is_broadcast(const uint8_t *frame_data) {
    static const uint8_t broadcast_mac[ETH_ALEN] = {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF};
    
    if (!frame_data) {
        return false;
    }
    
    return memcmp(frame_data, broadcast_mac, ETH_ALEN) == 0;
}

/**
 * @brief Check if packet is multicast
 * @param frame_data Frame data
 * @return true if multicast packet
 */
bool packet_is_multicast(const uint8_t *frame_data) {
    if (!frame_data) {
        return false;
    }
    
    /* Multicast bit is LSB of first octet */
    return (frame_data[0] & 0x01) != 0;
}

/**
 * @brief Get EtherType from frame
 * @param frame_data Frame data
 * @return EtherType value
 */
uint16_t packet_get_ethertype(const uint8_t *frame_data) {
    if (!frame_data) {
        return 0;
    }
    
    return ntohs(*(uint16_t*)(frame_data + 2 * ETH_ALEN));
}

/**\n * @brief Multi-NIC packet routing based on configuration\n * @param packet_data Packet data\n * @param length Packet length\n * @param src_nic_index Source NIC index (for received packets)\n * @return Target NIC index, or negative for local delivery\n */\nint packet_route_multi_nic(const uint8_t *packet_data, uint16_t length, int src_nic_index) {\n    eth_header_t eth_header;\n    int total_nics;\n    int target_nic = -1;\n    \n    if (!packet_data || length < ETH_HEADER_LEN) {\n        return -1;\n    }\n    \n    /* Parse Ethernet header for routing decisions */\n    if (packet_parse_ethernet_header(packet_data, length, &eth_header) < 0) {\n        return -1;\n    }\n    \n    /* Get total number of NICs */\n    total_nics = hardware_get_nic_count();\n    if (total_nics <= 1) {\n        /* Single NIC - no routing needed */\n        return -1;\n    }\n    \n    /* Check if this is a broadcast packet - send to all other NICs */\n    if (packet_is_broadcast(packet_data)) {\n        log_debug(\"Broadcast packet - would forward to all NICs except source %d\", src_nic_index);\n        /* For now, deliver locally. Full implementation would queue to all other NICs */\n        return -1;\n    }\n    \n    /* Check if destination is on a different segment */\n    /* This is a simplified routing - real implementation would use routing table */\n    for (int i = 0; i < total_nics; i++) {\n        nic_info_t *nic = hardware_get_nic(i);\n        if (!nic || i == src_nic_index) {\n            continue;\n        }\n        \n        /* Check if destination MAC matches this NIC's subnet */\n        /* For now, use simple even/odd MAC address routing as example */\n        if ((eth_header.dest_mac[5] & 1) == (i & 1)) {\n            target_nic = i;\n            log_debug(\"Routing packet to NIC %d based on MAC address\", target_nic);\n            break;\n        }\n    }\n    \n    return target_nic;\n}\n\n/**\n * @brief Coordinate packet sending across multiple NICs with load balancing\n * @param packet_data Packet data\n * @param length Packet length\n * @param dest_addr Destination MAC address\n * @param handle Sender handle\n * @return 0 on success, negative on error\n */\nint packet_send_multi_nic(const uint8_t *packet_data, uint16_t length,\n                          const uint8_t *dest_addr, uint16_t handle) {\n    static int next_nic_index = 0; /* Simple round-robin counter */\n    int total_nics;\n    int selected_nic;\n    int result;\n    nic_info_t *nic;\n    \n    if (!packet_data || !dest_addr || length == 0) {\n        return PACKET_ERR_INVALID_PARAM;\n    }\n    \n    total_nics = hardware_get_nic_count();\n    if (total_nics == 0) {\n        log_error(\"No NICs available for transmission\");\n        return PACKET_ERR_INVALID_NIC;\n    }\n    \n    /* For broadcast packets, send on primary NIC */\n    if (packet_is_broadcast(packet_data)) {\n        selected_nic = 0;\n        log_debug(\"Broadcast packet - using primary NIC 0\");\n    }\n    /* For unicast, use load balancing or routing table */\n    else {\n        /* Simple round-robin load balancing for now */\n        /* Real implementation would use routing table lookup */\n        selected_nic = next_nic_index % total_nics;\n        next_nic_index = (next_nic_index + 1) % total_nics;\n        \n        /* Skip inactive NICs */\n        for (int attempts = 0; attempts < total_nics; attempts++) {\n            nic = hardware_get_nic(selected_nic);\n            if (nic && (nic->status & NIC_STATUS_ACTIVE)) {\n                break;\n            }\n            selected_nic = (selected_nic + 1) % total_nics;\n        }\n        \n        log_debug(\"Load balancing: selected NIC %d for transmission\", selected_nic);\n    }\n    \n    /* Send using the enhanced packet send function */\n    result = packet_send_enhanced(selected_nic, packet_data, length, dest_addr, handle);\n    if (result < 0) {\n        log_error(\"Failed to send packet via NIC %d: %d\", selected_nic, result);\n        return result;\n    }\n    \n    return 0;\n}\n\n/**\n * @brief Check and handle NIC failover\n * @param failed_nic_index Index of failed NIC\n * @return 0 on successful failover, negative on error\n */\nint packet_handle_nic_failover(int failed_nic_index) {\n    int total_nics;\n    int active_nics = 0;\n    nic_info_t *nic;\n    \n    log_warning(\"Handling failover for failed NIC %d\", failed_nic_index);\n    \n    total_nics = hardware_get_nic_count();\n    \n    /* Count active NICs */\n    for (int i = 0; i < total_nics; i++) {\n        nic = hardware_get_nic(i);\n        if (nic && (nic->status & NIC_STATUS_ACTIVE) && i != failed_nic_index) {\n            active_nics++;\n        }\n    }\n    \n    if (active_nics == 0) {\n        log_error(\"No active NICs available after failover\");\n        return PACKET_ERR_INVALID_NIC;\n    }\n    \n    log_info(\"Failover completed: %d active NICs remaining\", active_nics);\n    \n    /* Update routing to avoid failed NIC */\n    /* Real implementation would update routing table */\n    \n    return 0;\n}\n\n/**\n * @brief Get optimal NIC for packet transmission based on load and link status\n * @param packet_data Packet data for routing decisions\n * @param length Packet length\n * @return NIC index, or negative on error\n */\nint packet_get_optimal_nic(const uint8_t *packet_data, uint16_t length) {\n    int total_nics;\n    int best_nic = -1;\n    uint32_t best_score = 0;\n    nic_info_t *nic;\n    \n    total_nics = hardware_get_nic_count();\n    \n    for (int i = 0; i < total_nics; i++) {\n        nic = hardware_get_nic(i);\n        if (!nic || !(nic->status & NIC_STATUS_ACTIVE)) {\n            continue;\n        }\n        \n        /* Calculate score based on multiple factors */\n        uint32_t score = 100; /* Base score */\n        \n        /* Link quality factor */\n        if (nic->status & NIC_STATUS_LINK_UP) {\n            score += 50;\n        }\n        \n        /* Speed factor */\n        if (nic->status & NIC_STATUS_100MBPS) {\n            score += 30;\n        }\n        \n        /* Load factor (inverse of error rate) */\n        if (nic->tx_packets > 0) {\n            uint32_t error_rate = (nic->tx_errors * 100) / nic->tx_packets;\n            score += (100 - error_rate);\n        }\n        \n        /* Duplex factor */\n        if (nic->status & NIC_STATUS_FULL_DUPLEX) {\n            score += 20;\n        }\n        \n        if (score > best_score) {\n            best_score = score;\n            best_nic = i;\n        }\n    }\n    \n    if (best_nic >= 0) {\n        log_debug(\"Selected optimal NIC %d (score=%lu)\", best_nic, best_score);\n    }\n    \n    return best_nic;\n}\n\n/**
 * @brief Comprehensive loopback testing suite
 * This implements internal, external, and cross-NIC loopback testing
 */

/**
 * @brief Test internal loopback functionality
 * @param nic_index NIC to test
 * @param test_pattern Test pattern to use
 * @param pattern_size Size of test pattern
 * @return 0 on success, negative on error
 */
int packet_test_internal_loopback(int nic_index, const uint8_t *test_pattern, uint16_t pattern_size) {
    nic_info_t *nic;
    uint8_t test_frame[ETH_MAX_FRAME];
    uint8_t rx_buffer[ETH_MAX_FRAME];
    uint16_t frame_length;
    size_t rx_length;
    int result;
    uint32_t timeout_ms = 1000;
    uint32_t start_time;
    
    if (!test_pattern || pattern_size == 0 || pattern_size > ETH_MAX_DATA) {
        log_error("Invalid loopback test parameters");
        return PACKET_ERR_INVALID_PARAM;
    }
    
    nic = hardware_get_nic(nic_index);
    if (!nic) {
        log_error("Invalid NIC index for loopback test: %d", nic_index);
        return PACKET_ERR_INVALID_NIC;
    }
    
    if (!(nic->status & NIC_STATUS_ACTIVE)) {
        log_error("NIC %d not active for loopback test", nic_index);
        return PACKET_ERR_INVALID_NIC;
    }
    
    log_info("Starting internal loopback test on NIC %d", nic_index);
    
    /* Build test frame with broadcast destination */
    uint8_t broadcast_mac[ETH_ALEN] = {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF};\n    frame_length = packet_build_ethernet_frame(test_frame, sizeof(test_frame),\n                                              broadcast_mac, nic->mac,\n                                              0x0800, /* IP ethertype */\n                                              test_pattern, pattern_size);\n    \n    if (frame_length < 0) {\n        log_error(\"Failed to build loopback test frame\");\n        return frame_length;\n    }\n    \n    /* Enable internal loopback mode */\n    result = packet_enable_loopback_mode(nic, LOOPBACK_INTERNAL);\n    if (result != 0) {\n        log_error(\"Failed to enable internal loopback mode: %d\", result);\n        return result;\n    }\n    \n    /* Clear any pending RX packets */\n    rx_length = sizeof(rx_buffer);\n    while (packet_receive_from_nic(nic_index, rx_buffer, &rx_length) == 0) {\n        rx_length = sizeof(rx_buffer);\n    }\n    \n    /* Send test frame */\n    result = packet_send_enhanced(nic_index, test_pattern, pattern_size, broadcast_mac, 0x1234);\n    if (result != 0) {\n        log_error(\"Failed to send loopback test frame: %d\", result);\n        packet_disable_loopback_mode(nic);\n        return result;\n    }\n    \n    log_debug(\"Loopback test frame sent, waiting for reception...\");\n    \n    /* Wait for loopback reception */\n    start_time = stats_get_timestamp();\n    rx_length = sizeof(rx_buffer);\n    \n    while ((stats_get_timestamp() - start_time) < timeout_ms) {\n        result = packet_receive_from_nic(nic_index, rx_buffer, &rx_length);\n        \n        if (result == 0) {\n            /* Verify received frame */\n            if (rx_length >= ETH_HEADER_LEN + pattern_size) {\n                /* Extract payload from received frame */\n                uint8_t *rx_payload = rx_buffer + ETH_HEADER_LEN;\n                \n                if (memcmp(rx_payload, test_pattern, pattern_size) == 0) {\n                    log_info(\"Internal loopback test PASSED on NIC %d\", nic_index);\n                    packet_disable_loopback_mode(nic);\n                    return 0;\n                } else {\n                    log_error(\"Loopback data mismatch on NIC %d\", nic_index);\n                    packet_disable_loopback_mode(nic);\n                    return PACKET_ERR_INVALID_DATA;\n                }\n            }\n        }\n        \n        /* Brief delay before retry */\n        for (volatile int i = 0; i < 1000; i++);\n        rx_length = sizeof(rx_buffer);\n    }\n    \n    log_error(\"Internal loopback test TIMEOUT on NIC %d\", nic_index);\n    packet_disable_loopback_mode(nic);\n    return PACKET_ERR_TIMEOUT;\n}\n\n/**\n * @brief Test external loopback with physical connector\n * @param nic_index NIC to test\n * @param test_patterns Array of test patterns\n * @param num_patterns Number of test patterns\n * @return 0 on success, negative on error\n */\nint packet_test_external_loopback(int nic_index, const loopback_test_pattern_t *test_patterns, int num_patterns) {\n    nic_info_t *nic;\n    int passed_tests = 0;\n    int failed_tests = 0;\n    \n    if (!test_patterns || num_patterns <= 0) {\n        return PACKET_ERR_INVALID_PARAM;\n    }\n    \n    nic = hardware_get_nic(nic_index);\n    if (!nic) {\n        return PACKET_ERR_INVALID_NIC;\n    }\n    \n    log_info(\"Starting external loopback test on NIC %d (%d patterns)\", nic_index, num_patterns);\n    \n    /* Disable internal loopback, enable external */\n    int result = packet_enable_loopback_mode(nic, LOOPBACK_EXTERNAL);\n    if (result != 0) {\n        log_error(\"Failed to enable external loopback mode: %d\", result);\n        return result;\n    }\n    \n    /* Test each pattern */\n    for (int i = 0; i < num_patterns; i++) {\n        log_debug(\"Testing external loopback pattern %d: %s\", i, test_patterns[i].name);\n        \n        result = packet_test_single_loopback_pattern(nic_index, &test_patterns[i]);\n        if (result == 0) {\n            passed_tests++;\n            log_debug(\"Pattern %d PASSED\", i);\n        } else {\n            failed_tests++;\n            log_warning(\"Pattern %d FAILED: %d\", i, result);\n        }\n    }\n    \n    packet_disable_loopback_mode(nic);\n    \n    log_info(\"External loopback test completed: %d passed, %d failed\", passed_tests, failed_tests);\n    \n    return (failed_tests == 0) ? 0 : PACKET_ERR_LOOPBACK_FAILED;\n}\n\n/**\n * @brief Test cross-NIC loopback for multi-NIC validation\n * @param src_nic_index Source NIC\n * @param dest_nic_index Destination NIC \n * @param test_data Test data to send\n * @param data_size Size of test data\n * @return 0 on success, negative on error\n */\nint packet_test_cross_nic_loopback(int src_nic_index, int dest_nic_index, \n                                  const uint8_t *test_data, uint16_t data_size) {\n    nic_info_t *src_nic, *dest_nic;\n    uint8_t test_frame[ETH_MAX_FRAME];\n    uint8_t rx_buffer[ETH_MAX_FRAME];\n    uint16_t frame_length;\n    size_t rx_length;\n    int result;\n    uint32_t timeout_ms = 2000;  /* Longer timeout for cross-NIC */\n    uint32_t start_time;\n    \n    if (!test_data || data_size == 0 || src_nic_index == dest_nic_index) {\n        return PACKET_ERR_INVALID_PARAM;\n    }\n    \n    src_nic = hardware_get_nic(src_nic_index);\n    dest_nic = hardware_get_nic(dest_nic_index);\n    \n    if (!src_nic || !dest_nic) {\n        log_error(\"Invalid NIC indices for cross-NIC test: src=%d, dest=%d\", \n                 src_nic_index, dest_nic_index);\n        return PACKET_ERR_INVALID_NIC;\n    }\n    \n    if (!(src_nic->status & NIC_STATUS_ACTIVE) || !(dest_nic->status & NIC_STATUS_ACTIVE)) {\n        log_error(\"NICs not active for cross-NIC test\");\n        return PACKET_ERR_INVALID_NIC;\n    }\n    \n    log_info(\"Starting cross-NIC loopback test: NIC %d -> NIC %d\", src_nic_index, dest_nic_index);\n    \n    /* Build test frame addressed to destination NIC */\n    frame_length = packet_build_ethernet_frame(test_frame, sizeof(test_frame),\n                                              dest_nic->mac, src_nic->mac,\n                                              0x0800, /* IP ethertype */\n                                              test_data, data_size);\n    \n    if (frame_length < 0) {\n        log_error(\"Failed to build cross-NIC test frame\");\n        return frame_length;\n    }\n    \n    /* Enable promiscuous mode on destination NIC to receive all packets */\n    result = hardware_set_promiscuous_mode(dest_nic, true);\n    if (result != 0) {\n        log_warning(\"Failed to enable promiscuous mode on dest NIC %d\", dest_nic_index);\n    }\n    \n    /* Clear any pending packets on destination NIC */\n    rx_length = sizeof(rx_buffer);\n    while (packet_receive_from_nic(dest_nic_index, rx_buffer, &rx_length) == 0) {\n        rx_length = sizeof(rx_buffer);\n    }\n    \n    /* Send packet from source NIC */\n    result = packet_send_enhanced(src_nic_index, test_data, data_size, dest_nic->mac, 0x5678);\n    if (result != 0) {\n        log_error(\"Failed to send cross-NIC test packet: %d\", result);\n        hardware_set_promiscuous_mode(dest_nic, false);\n        return result;\n    }\n    \n    log_debug(\"Cross-NIC packet sent, waiting for reception on NIC %d...\", dest_nic_index);\n    \n    /* Wait for packet on destination NIC */\n    start_time = stats_get_timestamp();\n    rx_length = sizeof(rx_buffer);\n    \n    while ((stats_get_timestamp() - start_time) < timeout_ms) {\n        result = packet_receive_from_nic(dest_nic_index, rx_buffer, &rx_length);\n        \n        if (result == 0) {\n            /* Verify received frame */\n            eth_header_t eth_header;\n            result = packet_parse_ethernet_header(rx_buffer, rx_length, &eth_header);\n            \n            if (result == 0) {\n                /* Check if this is our test packet */\n                if (memcmp(eth_header.dest_mac, dest_nic->mac, ETH_ALEN) == 0 &&\n                    memcmp(eth_header.src_mac, src_nic->mac, ETH_ALEN) == 0) {\n                    \n                    /* Verify payload */\n                    uint8_t *rx_payload = rx_buffer + ETH_HEADER_LEN;\n                    uint16_t payload_length = rx_length - ETH_HEADER_LEN;\n                    \n                    if (payload_length >= data_size && \n                        memcmp(rx_payload, test_data, data_size) == 0) {\n                        log_info(\"Cross-NIC loopback test PASSED: NIC %d -> NIC %d\", \n                                src_nic_index, dest_nic_index);\n                        hardware_set_promiscuous_mode(dest_nic, false);\n                        return 0;\n                    } else {\n                        log_error(\"Cross-NIC payload mismatch\");\n                        hardware_set_promiscuous_mode(dest_nic, false);\n                        return PACKET_ERR_INVALID_DATA;\n                    }\n                }\n            }\n        }\n        \n        /* Brief delay before retry */\n        for (volatile int i = 0; i < 1000; i++);\n        rx_length = sizeof(rx_buffer);\n    }\n    \n    log_error(\"Cross-NIC loopback test TIMEOUT: NIC %d -> NIC %d\", src_nic_index, dest_nic_index);\n    hardware_set_promiscuous_mode(dest_nic, false);\n    return PACKET_ERR_TIMEOUT;\n}\n\n/**\n * @brief Comprehensive packet integrity verification during loopback\n * @param original_data Original packet data\n * @param received_data Received packet data\n * @param data_length Length of data to compare\n * @param integrity_result Pointer to store detailed integrity result\n * @return 0 if integrity check passed, negative on error\n */\nint packet_verify_loopback_integrity(const uint8_t *original_data, const uint8_t *received_data,\n                                    uint16_t data_length, packet_integrity_result_t *integrity_result) {\n    if (!original_data || !received_data || !integrity_result || data_length == 0) {\n        return PACKET_ERR_INVALID_PARAM;\n    }\n    \n    memset(integrity_result, 0, sizeof(packet_integrity_result_t));\n    integrity_result->bytes_compared = data_length;\n    \n    /* Byte-by-byte comparison */\n    for (uint16_t i = 0; i < data_length; i++) {\n        if (original_data[i] != received_data[i]) {\n            integrity_result->mismatch_count++;\n            \n            /* Store first few mismatches for debugging */\n            if (integrity_result->mismatch_count <= MAX_MISMATCH_DETAILS) {\n                packet_mismatch_detail_t *detail = \n                    &integrity_result->mismatch_details[integrity_result->mismatch_count - 1];\n                detail->offset = i;\n                detail->expected = original_data[i];\n                detail->actual = received_data[i];\n            }\n        }\n    }\n    \n    /* Calculate error statistics */\n    if (integrity_result->mismatch_count > 0) {\n        integrity_result->error_rate_percent = \n            (integrity_result->mismatch_count * 100) / data_length;\n        \n        /* Analyze error patterns */\n        packet_analyze_error_patterns(integrity_result);\n        \n        log_error(\"Packet integrity check FAILED: %d mismatches out of %d bytes (%.2f%%)\",\n                 integrity_result->mismatch_count, data_length, \n                 (float)integrity_result->error_rate_percent);\n        \n        return PACKET_ERR_INTEGRITY_FAILED;\n    }\n    \n    log_debug(\"Packet integrity check PASSED: %d bytes verified\", data_length);\n    return 0;\n}\n\n/**\n * @brief Enable loopback mode on a NIC\n * @param nic NIC to configure\n * @param loopback_type Type of loopback to enable\n * @return 0 on success, negative on error\n */\nstatic int packet_enable_loopback_mode(nic_info_t *nic, loopback_type_t loopback_type) {\n    if (!nic) {\n        return PACKET_ERR_INVALID_PARAM;\n    }\n    \n    log_debug(\"Enabling loopback mode %d on NIC %d\", loopback_type, nic->index);\n    \n    if (nic->type == NIC_TYPE_3C509B) {\n        return packet_enable_3c509b_loopback(nic, loopback_type);\n    } else if (nic->type == NIC_TYPE_3C515_TX) {\n        return packet_enable_3c515_loopback(nic, loopback_type);\n    }\n    \n    return PACKET_ERR_NOT_SUPPORTED;\n}\n\n/**\n * @brief Disable loopback mode on a NIC\n * @param nic NIC to configure\n * @return 0 on success, negative on error\n */\nstatic int packet_disable_loopback_mode(nic_info_t *nic) {\n    if (!nic) {\n        return PACKET_ERR_INVALID_PARAM;\n    }\n    \n    log_debug(\"Disabling loopback mode on NIC %d\", nic->index);\n    \n    if (nic->type == NIC_TYPE_3C509B) {\n        return packet_disable_3c509b_loopback(nic);\n    } else if (nic->type == NIC_TYPE_3C515_TX) {\n        return packet_disable_3c515_loopback(nic);\n    }\n    \n    return PACKET_ERR_NOT_SUPPORTED;\n}\n\n/**\n * @brief Enable 3C509B loopback mode\n * @param nic NIC to configure\n * @param loopback_type Type of loopback\n * @return 0 on success, negative on error\n */\nstatic int packet_enable_3c509b_loopback(nic_info_t *nic, loopback_type_t loopback_type) {\n    uint16_t rx_filter = 0x01;  /* Individual address */\n    \n    _3C509B_SELECT_WINDOW(nic->io_base, _3C509B_WINDOW_0);\n    \n    switch (loopback_type) {\n        case LOOPBACK_INTERNAL:\n            /* Set internal loopback in RX filter */\n            rx_filter |= 0x08;  /* Loopback mode */\n            break;\n            \n        case LOOPBACK_EXTERNAL:\n            /* External loopback requires physical connector */\n            /* No special register settings needed */\n            break;\n            \n        default:\n            return PACKET_ERR_INVALID_PARAM;\n    }\n    \n    /* Apply RX filter settings */\n    outw(nic->io_base + _3C509B_COMMAND_REG, _3C509B_CMD_SET_RX_FILTER | rx_filter);\n    \n    /* Enable TX and RX */\n    outw(nic->io_base + _3C509B_COMMAND_REG, _3C509B_CMD_TX_ENABLE);\n    outw(nic->io_base + _3C509B_COMMAND_REG, _3C509B_CMD_RX_ENABLE);\n    \n    return 0;\n}\n\n/**\n * @brief Enable 3C515-TX loopback mode\n * @param nic NIC to configure\n * @param loopback_type Type of loopback\n * @return 0 on success, negative on error\n */\nstatic int packet_enable_3c515_loopback(nic_info_t *nic, loopback_type_t loopback_type) {\n    _3C515_TX_SELECT_WINDOW(nic->io_base, _3C515_TX_WINDOW_4);\n    \n    uint16_t media_options = inw(nic->io_base + _3C515_TX_MEDIA_OPTIONS_REG);\n    \n    switch (loopback_type) {\n        case LOOPBACK_INTERNAL:\n            /* Enable internal loopback */\n            media_options |= 0x0008;  /* Internal loopback bit */\n            break;\n            \n        case LOOPBACK_EXTERNAL:\n            /* Disable internal loopback for external testing */\n            media_options &= ~0x0008;\n            break;\n            \n        default:\n            return PACKET_ERR_INVALID_PARAM;\n    }\n    \n    outw(nic->io_base + _3C515_TX_MEDIA_OPTIONS_REG, media_options);\n    \n    /* Enable TX and RX */\n    _3C515_TX_SELECT_WINDOW(nic->io_base, _3C515_TX_WINDOW_1);\n    outw(nic->io_base + _3C515_TX_COMMAND_REG, _3C515_TX_CMD_TX_ENABLE);\n    outw(nic->io_base + _3C515_TX_COMMAND_REG, _3C515_TX_CMD_RX_ENABLE);\n    \n    return 0;\n}\n\n/**\n * @brief Disable 3C509B loopback mode\n * @param nic NIC to configure\n * @return 0 on success, negative on error\n */\nstatic int packet_disable_3c509b_loopback(nic_info_t *nic) {\n    _3C509B_SELECT_WINDOW(nic->io_base, _3C509B_WINDOW_0);\n    \n    /* Reset to normal RX filter (individual + broadcast) */\n    uint16_t rx_filter = 0x01 | 0x02;  /* Individual + broadcast */\n    outw(nic->io_base + _3C509B_COMMAND_REG, _3C509B_CMD_SET_RX_FILTER | rx_filter);\n    \n    return 0;\n}\n\n/**\n * @brief Disable 3C515-TX loopback mode\n * @param nic NIC to configure\n * @return 0 on success, negative on error\n */\nstatic int packet_disable_3c515_loopback(nic_info_t *nic) {\n    _3C515_TX_SELECT_WINDOW(nic->io_base, _3C515_TX_WINDOW_4);\n    \n    /* Disable internal loopback */\n    uint16_t media_options = inw(nic->io_base + _3C515_TX_MEDIA_OPTIONS_REG);\n    media_options &= ~0x0008;  /* Clear internal loopback bit */\n    outw(nic->io_base + _3C515_TX_MEDIA_OPTIONS_REG, media_options);\n    \n    return 0;\n}\n\n/**\n * @brief Test a single loopback pattern\n * @param nic_index NIC to test\n * @param pattern Test pattern to use\n * @return 0 on success, negative on error\n */\nstatic int packet_test_single_loopback_pattern(int nic_index, const loopback_test_pattern_t *pattern) {\n    uint8_t rx_buffer[ETH_MAX_FRAME];\n    size_t rx_length;\n    packet_integrity_result_t integrity_result;\n    int result;\n    uint32_t timeout_ms = pattern->timeout_ms ? pattern->timeout_ms : 1000;\n    uint32_t start_time;\n    \n    /* Send test pattern */\n    result = packet_test_internal_loopback(nic_index, pattern->data, pattern->size);\n    if (result != 0) {\n        return result;\n    }\n    \n    return 0;  /* Success if internal loopback passed */\n}\n\n/**\n * @brief Analyze error patterns in received data\n * @param integrity_result Integrity result to analyze\n */\nstatic void packet_analyze_error_patterns(packet_integrity_result_t *integrity_result) {\n    if (!integrity_result || integrity_result->mismatch_count == 0) {\n        return;\n    }\n    \n    /* Look for common error patterns */\n    int bit_errors = 0;\n    int byte_shifts = 0;\n    int burst_errors = 0;\n    \n    for (int i = 0; i < integrity_result->mismatch_count && i < MAX_MISMATCH_DETAILS; i++) {\n        packet_mismatch_detail_t *detail = &integrity_result->mismatch_details[i];\n        uint8_t xor_result = detail->expected ^ detail->actual;\n        \n        /* Count bit errors */\n        int bits_different = 0;\n        for (int bit = 0; bit < 8; bit++) {\n            if (xor_result & (1 << bit)) {\n                bits_different++;\n            }\n        }\n        \n        if (bits_different == 1) {\n            bit_errors++;\n        }\n        \n        /* Check for byte shift patterns */\n        if (i > 0) {\n            packet_mismatch_detail_t *prev = &integrity_result->mismatch_details[i - 1];\n            if (detail->offset == prev->offset + 1) {\n                burst_errors++;\n            }\n        }\n    }\n    \n    /* Store pattern analysis results */\n    integrity_result->single_bit_errors = bit_errors;\n    integrity_result->burst_errors = burst_errors;\n    \n    /* Determine likely error cause */\n    if (bit_errors > burst_errors) {\n        strcpy(integrity_result->error_pattern_description, \"Single-bit errors (electrical noise)\");\n    } else if (burst_errors > 0) {\n        strcpy(integrity_result->error_pattern_description, \"Burst errors (synchronization issue)\");\n    } else {\n        strcpy(integrity_result->error_pattern_description, \"Random data corruption\");\n    }\n}\n\n/**\n * @brief Route packet to another interface\n * @param packet Packet data\n * @param length Packet length\n * @param dest_nic Destination NIC index\n * @return 0 on success, negative on error\n */\nstatic int route_packet_to_interface(const uint8_t *packet, uint16_t length, uint8_t dest_nic) {
    nic_info_t *nic;
    ip_addr_t dest_ip;
    uint8_t dest_mac[ETH_ALEN];
    uint8_t nic_index;
    int result;
    
    if (!packet || length == 0) {
        return ERROR_INVALID_PARAM;
    }
    
    /* Get destination NIC */
    nic = hardware_get_nic(dest_nic);
    if (!nic || !(nic->status & NIC_STATUS_ACTIVE)) {
        log_error("Destination NIC %d not active", dest_nic);
        return ERROR_INVALID_PARAM;
    }
    
    /* For IP packets, we need to resolve MAC address via ARP */
    if (packet_get_ethertype(packet) == ETH_P_IP) {
        /* Extract destination IP from IP header */
        const uint8_t *ip_header = packet + ETH_HEADER_LEN;
        memory_copy(dest_ip.addr, ip_header + 16, 4); /* Dest IP at offset 16 */
        
        /* Try to resolve MAC address */
        if (arp_is_enabled()) {
            result = arp_resolve(&dest_ip, dest_mac, &nic_index);
            if (result == SUCCESS) {
                /* Update destination MAC in packet */
                uint8_t *mutable_packet = (uint8_t*)packet;
                memory_copy(mutable_packet, dest_mac, ETH_ALEN);
                
                /* Update source MAC to our NIC's MAC */
                memory_copy(mutable_packet + ETH_ALEN, nic->mac, ETH_ALEN);
            } else if (result == ERROR_BUSY) {
                /* ARP resolution in progress - queue packet or drop */
                log_debug("ARP resolution pending for routing, dropping packet");
                return ERROR_BUSY;
            } else {
                /* ARP resolution failed */
                log_warning("ARP resolution failed for routing, dropping packet");
                return ERROR_NOT_FOUND;
            }
        }
    }
    
    /* Send packet on destination interface */
    result = hardware_send_packet(nic, packet, length);
    if (result < 0) {
        log_error("Failed to send routed packet on NIC %d: %d", dest_nic, result);
        return result;
    }
    
    log_debug("Successfully routed packet to NIC %d", dest_nic);
    return SUCCESS;
}

COLD_SECTION int packet_ops_cleanup(void) {
    if (!packet_ops_initialized) {
        return 0;
    }
    
    log_info("Cleaning up packet operations subsystem");
    
    /* Cleanup production queue management */
    packet_queue_cleanup_all();
    
    /* Print final statistics */
    log_info("Final packet statistics:");
    log_info("  TX: %lu packets, %lu bytes, %lu errors",
             packet_statistics.tx_packets, 
             packet_statistics.tx_bytes,
             packet_statistics.tx_errors);
    log_info("  RX: %lu packets, %lu bytes, %lu errors, %lu dropped",
             packet_statistics.rx_packets,
             packet_statistics.rx_bytes, 
             packet_statistics.rx_errors,
             packet_statistics.rx_dropped);
    
    /* Print queue management statistics */
    log_info("Queue Statistics:");
    log_info("  Queue full events: %lu", g_queue_state.queue_full_events);
    log_info("  Backpressure events: %lu", g_queue_state.backpressure_events);
    log_info("  Priority drops: %lu", g_queue_state.priority_drops);
    log_info("  Adaptive resizes: %lu", g_queue_state.adaptive_resizes);
    
    packet_ops_initialized = 0;
    
    log_info("Packet operations cleanup completed");
    return 0;
}

/**
 * @brief Initialize all production packet queues
 * @return 0 on success, negative on error
 */
COLD_SECTION static int packet_queue_init_all(void) {
    int result;
    
    log_info("Initializing production packet queues");
    
    /* Initialize priority-based TX queues */
    result = packet_queue_init(&g_queue_state.tx_queues[PACKET_PRIORITY_URGENT], 
                              TX_QUEUE_URGENT_SIZE, TX_QUEUE_URGENT_SIZE * 1514);
    if (result != 0) {
        log_error("Failed to initialize urgent TX queue");
        return result;
    }
    
    result = packet_queue_init(&g_queue_state.tx_queues[PACKET_PRIORITY_HIGH], 
                              TX_QUEUE_HIGH_SIZE, TX_QUEUE_HIGH_SIZE * 1514);
    if (result != 0) {
        log_error("Failed to initialize high priority TX queue");
        return result;
    }
    
    result = packet_queue_init(&g_queue_state.tx_queues[PACKET_PRIORITY_NORMAL], 
                              TX_QUEUE_NORMAL_SIZE, TX_QUEUE_NORMAL_SIZE * 1514);
    if (result != 0) {
        log_error("Failed to initialize normal priority TX queue");
        return result;
    }
    
    result = packet_queue_init(&g_queue_state.tx_queues[PACKET_PRIORITY_LOW], 
                              TX_QUEUE_LOW_SIZE, TX_QUEUE_LOW_SIZE * 1514);
    if (result != 0) {
        log_error("Failed to initialize low priority TX queue");
        return result;
    }
    
    /* Initialize RX queue */
    result = packet_queue_init(&g_queue_state.rx_queue, 
                              RX_QUEUE_SIZE, RX_QUEUE_SIZE * 1514);
    if (result != 0) {
        log_error("Failed to initialize RX queue");
        return result;
    }
    
    log_info("Production packet queues initialized successfully");
    return 0;
}

/**
 * @brief Cleanup all production packet queues
 */
COLD_SECTION static void packet_queue_cleanup_all(void) {
    log_info("Cleaning up production packet queues");
    
    /* Emergency drain all queues before cleanup */
    packet_emergency_queue_drain();
    
    /* Cleanup TX queues */
    for (int i = 0; i < 4; i++) {
        packet_queue_cleanup(&g_queue_state.tx_queues[i]);
    }
    
    /* Cleanup RX queue */
    packet_queue_cleanup(&g_queue_state.rx_queue);
    
    log_info("Production packet queues cleaned up");
}

/**
 * @brief Enqueue packet with priority-based flow control
 * @param buffer Packet buffer
 * @param priority Packet priority (0-3)
 * @return 0 on success, negative on error
 */
static int packet_enqueue_with_priority(packet_buffer_t *buffer, int priority) {
    packet_queue_t *queue;
    int result;
    uint32_t queue_usage;
    
    if (!buffer || priority < 0 || priority > 3) {
        return PACKET_ERR_INVALID_PARAM;
    }
    
    queue = &g_queue_state.tx_queues[priority];
    queue_usage = packet_calculate_queue_usage(queue);
    
    /* Check for queue overflow */
    if (packet_queue_is_full(queue)) {
        log_debug("Queue %d full, checking drop policy", priority);
        
        if (packet_should_drop_on_full(priority, queue_usage)) {
            /* Drop lower priority packets to make room if possible */
            packet_handle_queue_overflow(priority);
            
            /* Try again after making room */
            if (packet_queue_is_full(queue)) {
                g_queue_state.queue_full_events++;
                g_queue_state.priority_drops++;
                log_warning("Dropping packet due to queue %d overflow", priority);
                return PACKET_ERR_NO_BUFFERS;
            }
        } else {
            g_queue_state.queue_full_events++;
            return PACKET_ERR_NO_BUFFERS;
        }
    }
    
    /* Check for flow control threshold */
    if (queue_usage > FLOW_CONTROL_THRESHOLD) {
        if (!g_queue_state.flow_control_active) {
            log_info("Activating flow control - queue usage %d%%", queue_usage);
            g_queue_state.flow_control_active = true;
            g_queue_state.backpressure_events++;
        }
        packet_apply_flow_control();
    }
    
    /* Enqueue the packet - CRITICAL SECTION */
    __asm__ __volatile__("cli");  /* Disable interrupts */
    result = packet_queue_enqueue(queue, buffer);
    __asm__ __volatile__("sti");  /* Enable interrupts */
    if (result != 0) {
        log_error("Failed to enqueue packet to priority queue %d", priority);
        return result;
    }
    
    log_trace("Enqueued packet to priority %d queue (usage: %d%%)", priority, queue_usage);
    return 0;
}

/**
 * @brief Dequeue packet using priority scheduling
 * @return Packet buffer or NULL if no packets
 */
static packet_buffer_t* packet_dequeue_by_priority(void) {
    packet_buffer_t *buffer = NULL;
    
    /* Check queues in priority order (urgent first) */
    for (int priority = PACKET_PRIORITY_URGENT; priority >= PACKET_PRIORITY_LOW; priority--) {
        if (!packet_queue_is_empty(&g_queue_state.tx_queues[priority])) {
            /* Dequeue from priority queue - CRITICAL SECTION */
            __asm__ __volatile__("cli");  /* Disable interrupts */
            buffer = packet_queue_dequeue(&g_queue_state.tx_queues[priority]);
            __asm__ __volatile__("sti");  /* Enable interrupts */
            if (buffer) {
                log_trace("Dequeued packet from priority %d queue", priority);
                
                /* Check if we can disable flow control */
                uint32_t total_usage = 0;
                for (int i = 0; i < 4; i++) {
                    total_usage += packet_calculate_queue_usage(&g_queue_state.tx_queues[i]);
                }
                
                if (g_queue_state.flow_control_active && total_usage < QUEUE_WATERMARK_LOW) {
                    log_info("Deactivating flow control - total usage %d%%", total_usage / 4);
                    g_queue_state.flow_control_active = false;
                }
                
                return buffer;
            }
        }
    }
    
    return NULL;
}

/**
 * @brief Check queue health and trigger adaptive management
 * @return 0 on success, negative on error
 */
static int packet_check_queue_health(void) {
    uint32_t current_time = stats_get_timestamp();
    bool health_issues = false;
    
    /* Only check periodically */
    if (current_time - g_queue_state.last_queue_check < QUEUE_CHECK_INTERVAL_MS) {
        return 0;
    }
    
    g_queue_state.last_queue_check = current_time;
    
    /* Check each TX queue for health issues */
    for (int i = 0; i < 4; i++) {
        packet_queue_t *queue = &g_queue_state.tx_queues[i];
        uint32_t usage = packet_calculate_queue_usage(queue);
        
        if (usage > QUEUE_WATERMARK_HIGH) {
            log_warning("Queue %d usage high: %d%%", i, usage);
            health_issues = true;
        }
        
        /* Check for stale packets (simplified - would need timestamps) */
        if (queue->count > 0) {
            packet_buffer_t *head = packet_queue_peek(queue);
            if (head && head->timestamp > 0) {
                uint32_t age = current_time - head->timestamp;
                if (age > 5000) {  /* 5 second threshold */
                    log_warning("Stale packets detected in queue %d (age: %dms)", i, age);
                    health_issues = true;
                }
            }
        }
    }
    
    /* Check RX queue health */
    uint32_t rx_usage = packet_calculate_queue_usage(&g_queue_state.rx_queue);
    if (rx_usage > QUEUE_WATERMARK_HIGH) {
        log_warning("RX queue usage high: %d%%", rx_usage);
        health_issues = true;
    }
    
    /* Trigger adaptive management if needed */
    if (health_issues) {
        packet_adaptive_queue_resize();
    }
    
    return health_issues ? 1 : 0;
}

/**
 * @brief Apply flow control backpressure
 */
static void packet_apply_flow_control(void) {
    /* In a full implementation, this would:
     * 1. Signal upper layers to slow down
     * 2. Implement TCP-like window scaling
     * 3. Adjust NIC interrupt rates
     * 4. Apply per-connection throttling
     */
    
    log_debug("Applying flow control backpressure");
    
    /* For now, just add a small delay to slow down packet processing */
    for (volatile int i = 0; i < 100; i++) {
        /* Brief backpressure delay */
    }
}

/**
 * @brief Adaptively resize queues based on load
 */
static void packet_adaptive_queue_resize(void) {
    static uint32_t last_resize = 0;
    uint32_t current_time = stats_get_timestamp();
    
    /* Limit resize frequency */
    if (current_time - last_resize < 10000) {  /* 10 second minimum */
        return;
    }
    
    last_resize = current_time;
    
    log_info("Performing adaptive queue resize analysis");
    
    /* Analyze queue usage patterns */
    for (int i = 0; i < 4; i++) {
        packet_queue_t *queue = &g_queue_state.tx_queues[i];
        uint32_t usage = packet_calculate_queue_usage(queue);
        
        if (usage > 90 && queue->max_count < 512) {
            /* Queue consistently full - consider expansion */
            log_info("Queue %d consistently full (%d%%), would expand if possible", i, usage);
            /* In full implementation, would dynamically resize */
            g_queue_state.adaptive_resizes++;
        } else if (usage < 10 && queue->max_count > 32) {
            /* Queue underutilized - consider shrinking */
            log_info("Queue %d underutilized (%d%%), would shrink if possible", i, usage);
            g_queue_state.adaptive_resizes++;
        }
    }
}

/**
 * @brief Handle queue overflow by dropping lower priority packets
 * @param priority Current priority level
 */
static void packet_handle_queue_overflow(int priority) {
    int dropped = 0;
    
    /* Try to drop packets from lower priority queues */
    for (int lower_priority = PACKET_PRIORITY_LOW; lower_priority < priority; lower_priority++) {
        packet_queue_t *lower_queue = &g_queue_state.tx_queues[lower_priority];
        
        while (!packet_queue_is_empty(lower_queue) && dropped < 5) {
            packet_buffer_t *dropped_buffer = packet_queue_dequeue(lower_queue);
            if (dropped_buffer) {
                packet_buffer_free(dropped_buffer);
                dropped++;
                g_queue_state.priority_drops++;
            }
        }
        
        if (dropped >= 5) break;  /* Don't drop too many at once */
    }
    
    if (dropped > 0) {
        log_info("Dropped %d lower priority packets to make room for priority %d", dropped, priority);
    }
}

/**
 * @brief Check if packet should be dropped when queue is full
 * @param priority Packet priority
 * @param queue_usage Current queue usage percentage
 * @return true if should drop
 */
static bool packet_should_drop_on_full(int priority, int queue_usage) {
    /* Higher priority packets are more likely to preempt lower priority */
    switch (priority) {
        case PACKET_PRIORITY_URGENT:
            return true;   /* Always try to make room for urgent packets */
        case PACKET_PRIORITY_HIGH:
            return queue_usage > 95;  /* Drop if very full */
        case PACKET_PRIORITY_NORMAL:
            return queue_usage > 90;  /* Drop if mostly full */
        case PACKET_PRIORITY_LOW:
            return false;  /* Don't preempt others for low priority */
        default:
            return false;
    }
}

/**
 * @brief Calculate queue usage percentage
 * @param queue Queue to check
 * @return Usage percentage (0-100)
 */
static uint32_t packet_calculate_queue_usage(packet_queue_t *queue) {
    if (!queue || queue->max_count == 0) {
        return 0;
    }
    
    return (queue->count * 100) / queue->max_count;
}

/**
 * @brief Update queue management statistics
 */
static void packet_update_queue_stats(void) {
    /* This would update detailed queue statistics */
    /* For now, statistics are updated inline in other functions */
}

/**
 * @brief Emergency drain all queues (e.g., during shutdown)
 * @return Number of packets drained
 */
static int packet_emergency_queue_drain(void) {
    int total_drained = 0;
    
    log_warning("Emergency draining all packet queues");
    
    /* Drain TX queues */
    for (int i = 0; i < 4; i++) {
        packet_queue_t *queue = &g_queue_state.tx_queues[i];
        int drained = 0;
        
        while (!packet_queue_is_empty(queue)) {
            packet_buffer_t *buffer = packet_queue_dequeue(queue);
            if (buffer) {
                packet_buffer_free(buffer);
                drained++;
            }
        }
        
        if (drained > 0) {
            log_info("Drained %d packets from TX queue %d", drained, i);
            total_drained += drained;
        }
    }
    
    /* Drain RX queue */
    int rx_drained = 0;
    while (!packet_queue_is_empty(&g_queue_state.rx_queue)) {
        packet_buffer_t *buffer = packet_queue_dequeue(&g_queue_state.rx_queue);
        if (buffer) {
            packet_buffer_free(buffer);
            rx_drained++;
        }
    }
    
    if (rx_drained > 0) {
        log_info("Drained %d packets from RX queue", rx_drained);
        total_drained += rx_drained;
    }
    
    log_info("Emergency drain completed: %d total packets drained", total_drained);
    return total_drained;
}

/**
 * @brief Enhanced packet queue TX with production features
 * @param packet Packet data
 * @param length Packet length
 * @param priority Packet priority (0-3)
 * @param handle Sender handle
 * @return 0 on success, negative on error
 */
int packet_queue_tx_enhanced(const uint8_t *packet, size_t length, int priority, uint16_t handle) {
    packet_buffer_t *buffer;
    int result;
    
    if (!packet || length == 0 || priority < 0 || priority > 3) {
        return PACKET_ERR_INVALID_PARAM;
    }
    
    if (!packet_ops_initialized) {
        return PACKET_ERR_NOT_INITIALIZED;
    }
    
    /* Check queue health periodically */
    packet_check_queue_health();
    
    /* Allocate packet buffer */
    buffer = packet_buffer_alloc(length);
    if (!buffer) {
        log_error("Failed to allocate packet buffer for queuing");
        return PACKET_ERR_NO_BUFFERS;
    }
    
    /* Copy packet data and set metadata */
    result = packet_set_data(buffer, packet, length);
    if (result != 0) {
        packet_buffer_free(buffer);
        return result;
    }
    
    buffer->priority = priority;
    buffer->handle = handle;
    buffer->timestamp = stats_get_timestamp();
    
    /* Enqueue with priority management */
    result = packet_enqueue_with_priority(buffer, priority);
    if (result != 0) {
        packet_buffer_free(buffer);
        return result;
    }
    
    log_debug("Queued packet for transmission: priority=%d, length=%zu, handle=%04X",
              priority, length, handle);
    
    return 0;
}

/**
 * @brief Enhanced packet queue flush with priority scheduling
 * @return Number of packets processed, negative on error
 */
int packet_flush_tx_queue_enhanced(void) {
    int packets_sent = 0;
    int max_packets = 32;  /* Limit to prevent starvation */
    packet_buffer_t *buffer;
    int result;
    
    if (!packet_ops_initialized) {
        return PACKET_ERR_NOT_INITIALIZED;
    }
    
    /* Process packets by priority until queue empty or limit reached */
    while (packets_sent < max_packets) {
        buffer = packet_dequeue_by_priority();
        if (!buffer) {
            break;  /* No more packets */
        }
        
        /* Send the packet using enhanced send with recovery */
        result = packet_send_with_retry(buffer->data, buffer->length, 
                                       NULL, buffer->handle, 3);
        
        if (result == 0) {
            packets_sent++;
            log_trace("Successfully sent queued packet (handle=%04X)", buffer->handle);
        } else {
            log_warning("Failed to send queued packet: %d", result);
            
            /* For failed packets, could implement retry logic or dead letter queue */
        }
        
        packet_buffer_free(buffer);
    }
    
    if (packets_sent > 0) {
        log_debug("Flushed %d packets from TX queues", packets_sent);
    }
    
    return packets_sent;
}

/**
 * @brief Get comprehensive queue management statistics
 * @param stats Pointer to store statistics
 * @return 0 on success, negative on error
 */
int packet_get_queue_stats(packet_queue_management_stats_t *stats) {
    if (!stats) {
        return PACKET_ERR_INVALID_PARAM;
    }
    
    memset(stats, 0, sizeof(packet_queue_management_stats_t));
    
    /* Copy queue counts and usage */
    for (int i = 0; i < 4; i++) {
        stats->tx_queue_counts[i] = g_queue_state.tx_queues[i].count;
        stats->tx_queue_max[i] = g_queue_state.tx_queues[i].max_count;
        stats->tx_queue_usage[i] = packet_calculate_queue_usage(&g_queue_state.tx_queues[i]);
        stats->tx_queue_dropped[i] = g_queue_state.tx_queues[i].dropped_packets;
    }
    
    stats->rx_queue_count = g_queue_state.rx_queue.count;
    stats->rx_queue_max = g_queue_state.rx_queue.max_count;
    stats->rx_queue_usage = packet_calculate_queue_usage(&g_queue_state.rx_queue);
    stats->rx_queue_dropped = g_queue_state.rx_queue.dropped_packets;
    
    /* Copy management statistics */
    stats->queue_full_events = g_queue_state.queue_full_events;
    stats->backpressure_events = g_queue_state.backpressure_events;
    stats->priority_drops = g_queue_state.priority_drops;
    stats->adaptive_resizes = g_queue_state.adaptive_resizes;
    stats->flow_control_active = g_queue_state.flow_control_active;
    
    return 0;
}"

